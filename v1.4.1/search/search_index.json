{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"code/","title":"Modules","text":""},{"location":"code/#overview","title":"Overview","text":"<p>These are the modules used in this package:</p> Module Description Classes The <code>classes</code> module is designed for functions to be executed on classes; not within classes.For any methods/functions that should be added to classes, you should consider re-designing the original class, or sub-classing it to make further alterations. Bools The <code>bools</code> module is used how to manipulate and enhance Python booleans.Primarily, this module is used to store the <code>strtobool()</code> function, which used to be found in the <code>distutils.util</code> module, until it was deprecated. As mentioned in PEP632, we should re-implement this function in our own code. And that's what we've done here. Lists The <code>lists</code> module is used how to manipulate and enhance Python lists.Note that functions in this module will only take-in and manipulate existing <code>list</code> objects, and also output <code>list</code> objects. It will not sub-class the base <code>list</code> object, or create new '<code>list</code>-like' objects. It will always remain pure python types at it's core. Strings The <code>strings</code> module is for manipulating and checking certain string objects. Dictionaries The <code>dictionaries</code> module is used how to manipulate and enhance Python dictionaries.Note that functions in this module will only take-in and manipulate existing <code>dict</code> objects, and also output <code>dict</code> objects. It will not sub-class the base <code>dict</code> object, or create new '<code>dict</code>-like' objects. It will always remain pure python types at it's core. Generators The <code>generators</code> module is for generating information as needed.Such functions are typically used to generate data that is not stored in a database or file, but rather computed on-the-fly based on input parameters. Checkers The <code>checkers</code> module provides functions to check certain values against other objects. It includes type checking, value validation, and membership checks. Output The <code>output</code> module is for streamlining how data is outputted.This includes <code>print()</code>'ing to the terminal and <code>log()</code>'ing to files. Retry The <code>retry</code> module is for enabling automatic retrying of a given function when a specific <code>Exception</code> is thrown. Defaults The <code>defaults</code> module is used how to set and control default values for our various Python processes."},{"location":"code/#testing","title":"Testing","text":"<p>This package is fully tested against:</p> <ol> <li>Unit tests</li> <li>Lint tests</li> <li>MyPy tests</li> <li>Build tests</li> </ol> <p>Tests are run in matrix against:</p> <ol> <li>Python Versions:<ol> <li><code>3.8</code></li> <li><code>3.9</code></li> <li><code>3.10</code></li> <li><code>3.11</code></li> <li><code>3.12</code></li> <li><code>3.13</code></li> </ol> </li> <li>Operatign Systems:<ol> <li><code>ubuntu-latest</code></li> <li><code>windows-latest</code></li> <li><code>macos-latest</code></li> </ol> </li> </ol>"},{"location":"code/#coverage","title":"Coverage","text":""},{"location":"code/bools/","title":"Bools","text":""},{"location":"code/bools/#toolbox_python.bools","title":"toolbox_python.bools","text":"<p>Summary</p> <p>The <code>bools</code> module is used how to manipulate and enhance Python booleans.</p> <p>Details</p> <p>Primarily, this module is used to store the <code>strtobool()</code> function, which used to be found in the <code>distutils.util</code> module, until it was deprecated. As mentioned in PEP632, we should re-implement this function in our own code. And that's what we've done here.</p>"},{"location":"code/bools/#toolbox_python.bools.STR_TO_BOOL_MAP","title":"STR_TO_BOOL_MAP  <code>module-attribute</code>","text":"<pre><code>STR_TO_BOOL_MAP: dict[str, bool] = {\n    \"y\": True,\n    \"yes\": True,\n    \"t\": True,\n    \"true\": True,\n    \"on\": True,\n    \"1\": True,\n    \"n\": False,\n    \"no\": False,\n    \"f\": False,\n    \"false\": False,\n    \"off\": False,\n    \"0\": False,\n}\n</code></pre> Summary <p>Map of string values to their corresponding boolean values.</p>"},{"location":"code/bools/#toolbox_python.bools.strtobool","title":"strtobool","text":"<pre><code>strtobool(value: str) -&gt; bool\n</code></pre> <p>Summary</p> <p>Convert a <code>str</code> value in to a <code>bool</code> value.</p> Details <p>This process is necessary because the <code>d</code>istutils` module was completely deprecated in Python 3.12.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The string value to convert. Valid input options are defined in <code>STR_TO_BOOL_MAP</code></p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value parse'ed in to <code>value</code> is not a valid value to be able to convert to a <code>bool</code> value.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A <code>True</code> or <code>False</code> value, having successfully converted <code>value</code>.</p> Examples Set up<pre><code>from toolbox_python.bools import strtobool\n</code></pre> <p>Example 1: `true` conversions<pre><code>&gt;&gt;&gt; print(strtobool(\"true\"))\n&gt;&gt;&gt; print(strtobool(\"t\"))\n&gt;&gt;&gt; print(strtobool(\"1\"))\n</code></pre> Terminal<pre><code>True\nTrue\nTrue\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Example 2: `false` conversions<pre><code>&gt;&gt;&gt; print(strtobool(\"false\"))\n&gt;&gt;&gt; print(strtobool(\"f\"))\n&gt;&gt;&gt; print(strtobool(\"0\"))\n</code></pre> Terminal<pre><code>False\nFalse\nFalse\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Example 3: invalid value<pre><code>&gt;&gt;&gt; print(strtobool(5))\n</code></pre> Terminal<pre><code>ValueError: Invalid bool value: '5'.\nFor `True`, must be one of: ['y', 'yes', 't', 'true', 'on', '1']\nFor `False`, must be one of: ['n', 'no', 'f', 'false', 'off', '0']\n</code></pre> <p>Conclusion: Invalid type.</p> References <ul> <li>PEP632</li> </ul> Source code in <code>src/toolbox_python/bools.py</code> <pre><code>def strtobool(value: str) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Convert a `#!py str` value in to a `#!py bool` value.\n\n    ???+ abstract \"Details\"\n        This process is necessary because the `d`istutils` module was completely deprecated in Python 3.12.\n\n    Params:\n        value (str):\n            The string value to convert. Valid input options are defined in [`STR_TO_BOOL_MAP`][toolbox_python.bools.STR_TO_BOOL_MAP]\n\n    Raises:\n        ValueError:\n            If the value parse'ed in to `value` is not a valid value to be able to convert to a `#!py bool` value.\n\n    Returns:\n        (bool):\n            A `#!py True` or `#!py False` value, having successfully converted `value`.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        from toolbox_python.bools import strtobool\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: `true` conversions\"}\n        &gt;&gt;&gt; print(strtobool(\"true\"))\n        &gt;&gt;&gt; print(strtobool(\"t\"))\n        &gt;&gt;&gt; print(strtobool(\"1\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        True\n        True\n        True\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: `false` conversions\"}\n        &gt;&gt;&gt; print(strtobool(\"false\"))\n        &gt;&gt;&gt; print(strtobool(\"f\"))\n        &gt;&gt;&gt; print(strtobool(\"0\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        False\n        False\n        False\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: invalid value\"}\n        &gt;&gt;&gt; print(strtobool(5))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        ValueError: Invalid bool value: '5'.\n        For `True`, must be one of: ['y', 'yes', 't', 'true', 'on', '1']\n        For `False`, must be one of: ['n', 'no', 'f', 'false', 'off', '0']\n        ```\n        !!! failure \"Conclusion: Invalid type.\"\n        &lt;/div&gt;\n\n    ??? question \"References\"\n        - [PEP632](https://peps.python.org/pep-0632/#migration-advice)\n    \"\"\"\n    try:\n        return STR_TO_BOOL_MAP[str(value).lower()]\n    except KeyError as exc:\n        raise ValueError(\n            f\"Invalid bool value: '{value}'.\\n\"\n            f\"For `True`, must be one of: {[key for key, val in STR_TO_BOOL_MAP.items() if val]}\\n\"\n            f\"For `False`, must be one of: {[key for key, val in STR_TO_BOOL_MAP.items() if not val]}\"\n        ) from exc\n</code></pre>"},{"location":"code/checkers/","title":"Checkers","text":""},{"location":"code/checkers/#toolbox_python.checkers","title":"toolbox_python.checkers","text":"<p>Summary</p> <p>This module provides functions to check certain values against other objects. It includes type checking, value validation, and membership checks.</p>"},{"location":"code/checkers/#constants","title":"Constants","text":"<p>Summary</p> <p>This module provides functions to check certain values against other objects. It includes type checking, value validation, and membership checks.</p>"},{"location":"code/checkers/#toolbox_python.checkers.OPERATORS","title":"OPERATORS  <code>module-attribute</code>","text":"<pre><code>OPERATORS: dict[str, Callable[[Any, Any], bool]] = {\n    \"&lt;\": lt,\n    \"&lt;=\": le,\n    \"&gt;\": gt,\n    \"&gt;=\": ge,\n    \"==\": eq,\n    \"!=\": ne,\n    \"in\": lambda a, b: a in b,\n    \"not in\": lambda a, b: a not in b,\n}\n</code></pre>"},{"location":"code/checkers/#is_-functions","title":"<code>is_*()</code> functions","text":"<p>Summary</p> <p>This module provides functions to check certain values against other objects. It includes type checking, value validation, and membership checks.</p>"},{"location":"code/checkers/#toolbox_python.checkers.is_value_of_type","title":"is_value_of_type","text":"<pre><code>is_value_of_type(value: Any, check_type: type) -&gt; bool\n</code></pre><pre><code>is_value_of_type(\n    value: Any, check_type: tuple[type, ...]\n) -&gt; bool\n</code></pre> <pre><code>is_value_of_type(\n    value: Any, check_type: Union[type, tuple[type, ...]]\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check if a given value is of a specified type or types.</p> Details <p>This function is used to verify if a given value matches a specified type or any of the types in a tuple of types.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <code>check_type</code> <code>Union[type, tuple[type]]</code> <p>The type or tuple of types to check against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the value is of the specified type or one of the specified types; <code>False</code> otherwise.</p> Examples <p>Check if a value is of a specific type:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import is_value_of_type\n&gt;&gt;&gt; value = 42\n&gt;&gt;&gt; check_type = int\n</code></pre> <p>Example 1: Check if value is of type `#!py int`<pre><code>&gt;&gt;&gt; is_value_of_type(value, check_type)\n</code></pre> Output<pre><code>True\n</code></pre> <p>Conclusion: The value is of type <code>int</code>.</p> <p>Example 2: Check if value is of type `#!py str`<pre><code>&gt;&gt;&gt; is_value_of_type(value, str)\n</code></pre> Output<pre><code>False\n</code></pre> <p>Conclusion: The value is not of type <code>str</code>.</p> See Also <ul> <li><code>is_value_of_type()</code></li> <li><code>is_type()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def is_value_of_type(value: Any, check_type: Union[type, tuple[type, ...]]) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check if a given value is of a specified type or types.\n\n    ???+ info \"Details\"\n        This function is used to verify if a given value matches a specified type or any of the types in a tuple of types.\n\n    Params:\n        value (Any):\n            The value to check.\n        check_type (Union[type, tuple[type]]):\n            The type or tuple of types to check against.\n\n    Returns:\n        (bool):\n            `#!py True` if the value is of the specified type or one of the specified types; `#!py False` otherwise.\n\n    ???+ example \"Examples\"\n\n        Check if a value is of a specific type:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import is_value_of_type\n        &gt;&gt;&gt; value = 42\n        &gt;&gt;&gt; check_type = int\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check if value is of type `#!py int`\"}\n        &gt;&gt;&gt; is_value_of_type(value, check_type)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        True\n        ```\n        !!! success \"Conclusion: The value is of type `#!py int`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check if value is of type `#!py str`\"}\n        &gt;&gt;&gt; is_value_of_type(value, str)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        False\n        ```\n        !!! failure \"Conclusion: The value is not of type `#!py str`.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_of_type()`][toolbox_python.checkers.is_value_of_type]\n        - [`is_type()`][toolbox_python.checkers.is_type]\n    \"\"\"\n    return isinstance(value, check_type)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_all_values_of_type","title":"is_all_values_of_type","text":"<pre><code>is_all_values_of_type(\n    values: any_collection,\n    check_type: Union[type, tuple[type, ...]],\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check if all values in an iterable are of a specified type or types.</p> Details <p>This function is used to verify if all values in a given iterable match a specified type or any of the types in a tuple of types.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>any_collection</code> <p>The iterable containing values to check.</p> required <code>check_type</code> <code>Union[type, tuple[type]]</code> <p>The type or tuple of types to check against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values are of the specified type or one of the specified types; <code>False</code> otherwise.</p> Examples <p>Check if all values in an iterable are of a specific type:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import is_all_values_of_type\n&gt;&gt;&gt; values = [1, 2, 3]\n&gt;&gt;&gt; check_type = int\n</code></pre> <p>Example 1: Check if all values are of type `#!py int`<pre><code>&gt;&gt;&gt; is_all_values_of_type(values, check_type)\n</code></pre> Output<pre><code>True\n</code></pre> <p>Conclusion: All values are of type <code>int</code>.</p> <p>Example 2: Check if all values are of type `#!py str`<pre><code>&gt;&gt;&gt; is_all_values_of_type(values, str)\n</code></pre> Output<pre><code>False\n</code></pre> <p>Conclusion: Not all values are of type <code>str</code>.</p> See Also <ul> <li><code>is_value_of_type()</code></li> <li><code>is_all_values_of_type()</code></li> <li><code>is_type()</code></li> <li><code>is_all_type()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def is_all_values_of_type(\n    values: any_collection,\n    check_type: Union[type, tuple[type, ...]],\n) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check if all values in an iterable are of a specified type or types.\n\n    ???+ info \"Details\"\n        This function is used to verify if all values in a given iterable match a specified type or any of the types in a tuple of types.\n\n    Params:\n        values (any_collection):\n            The iterable containing values to check.\n        check_type (Union[type, tuple[type]]):\n            The type or tuple of types to check against.\n\n    Returns:\n        (bool):\n            `#!py True` if all values are of the specified type or one of the specified types; `#!py False` otherwise.\n\n    ???+ example \"Examples\"\n\n        Check if all values in an iterable are of a specific type:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import is_all_values_of_type\n        &gt;&gt;&gt; values = [1, 2, 3]\n        &gt;&gt;&gt; check_type = int\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check if all values are of type `#!py int`\"}\n        &gt;&gt;&gt; is_all_values_of_type(values, check_type)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        True\n        ```\n        !!! success \"Conclusion: All values are of type `#!py int`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check if all values are of type `#!py str`\"}\n        &gt;&gt;&gt; is_all_values_of_type(values, str)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        False\n        ```\n        !!! failure \"Conclusion: Not all values are of type `#!py str`.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_of_type()`][toolbox_python.checkers.is_value_of_type]\n        - [`is_all_values_of_type()`][toolbox_python.checkers.is_all_values_of_type]\n        - [`is_type()`][toolbox_python.checkers.is_type]\n        - [`is_all_type()`][toolbox_python.checkers.is_all_type]\n    \"\"\"\n    return all(isinstance(value, check_type) for value in values)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_any_values_of_type","title":"is_any_values_of_type","text":"<pre><code>is_any_values_of_type(\n    values: any_collection,\n    check_type: Union[type, tuple[type, ...]],\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check if any value in an iterable is of a specified type or types.</p> Details <p>This function is used to verify if any value in a given iterable matches a specified type or any of the types in a tuple of types.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>any_collection</code> <p>The iterable containing values to check.</p> required <code>check_type</code> <code>Union[type, tuple[type]]</code> <p>The type or tuple of types to check against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if any value is of the specified type or one of the specified types; <code>False</code> otherwise.</p> Examples <p>Check if any value in an iterable is of a specific type:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import is_any_values_of_type\n&gt;&gt;&gt; values = [1, \"a\", 3.0]\n&gt;&gt;&gt; check_type = str\n</code></pre> <p>Example 1: Check if any value is of type `#!py str`<pre><code>&gt;&gt;&gt; is_any_values_of_type(values, check_type)\n</code></pre> Output<pre><code>True\n</code></pre> <p>Conclusion: At least one value is of type <code>str</code>.</p> <p>Example 2: Check if any value is of type `#!py dict`<pre><code>&gt;&gt;&gt; is_any_values_of_type(values, dict)\n</code></pre> Output<pre><code>False\n</code></pre> <p>Conclusion: No values are of type <code>dict</code>.</p> See Also <ul> <li><code>is_value_of_type()</code></li> <li><code>is_any_values_of_type()</code></li> <li><code>is_type()</code></li> <li><code>is_any_type()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def is_any_values_of_type(\n    values: any_collection,\n    check_type: Union[type, tuple[type, ...]],\n) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check if any value in an iterable is of a specified type or types.\n\n    ???+ info \"Details\"\n        This function is used to verify if any value in a given iterable matches a specified type or any of the types in a tuple of types.\n\n    Params:\n        values (any_collection):\n            The iterable containing values to check.\n        check_type (Union[type, tuple[type]]):\n            The type or tuple of types to check against.\n\n    Returns:\n        (bool):\n            `#!py True` if any value is of the specified type or one of the specified types; `#!py False` otherwise.\n\n    ???+ example \"Examples\"\n\n        Check if any value in an iterable is of a specific type:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import is_any_values_of_type\n        &gt;&gt;&gt; values = [1, \"a\", 3.0]\n        &gt;&gt;&gt; check_type = str\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check if any value is of type `#!py str`\"}\n        &gt;&gt;&gt; is_any_values_of_type(values, check_type)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        True\n        ```\n        !!! success \"Conclusion: At least one value is of type `#!py str`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check if any value is of type `#!py dict`\"}\n        &gt;&gt;&gt; is_any_values_of_type(values, dict)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        False\n        ```\n        !!! failure \"Conclusion: No values are of type `#!py dict`.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_of_type()`][toolbox_python.checkers.is_value_of_type]\n        - [`is_any_values_of_type()`][toolbox_python.checkers.is_any_values_of_type]\n        - [`is_type()`][toolbox_python.checkers.is_type]\n        - [`is_any_type()`][toolbox_python.checkers.is_any_type]\n    \"\"\"\n    return any(isinstance(value, check_type) for value in values)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_value_in_iterable","title":"is_value_in_iterable","text":"<pre><code>is_value_in_iterable(\n    value: scalar, iterable: any_collection\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check if a given value is present in an iterable.</p> Details <p>This function is used to verify if a given value exists within an iterable such as a list, tuple, or set.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>scalar</code> <p>The value to check.</p> required <code>iterable</code> <code>any_collection</code> <p>The iterable to check within.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the value is found in the iterable; <code>False</code> otherwise.</p> Examples <p>Check if a value is in an iterable:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import is_value_in_iterable\n&gt;&gt;&gt; value = 2\n&gt;&gt;&gt; iterable = [1, 2, 3]\n</code></pre> <p>Example 1: Check if value is in the iterable<pre><code>&gt;&gt;&gt; is_value_in_iterable(value, iterable)\n</code></pre> Output<pre><code>True\n</code></pre> <p>Conclusion: The value is in the iterable.</p> <p>Example 2: Check if value is not in the iterable<pre><code>&gt;&gt;&gt; is_value_in_iterable(4, iterable)\n</code></pre> Output<pre><code>False\n</code></pre> <p>Conclusion: The value is not in the iterable.</p> See Also <ul> <li><code>is_value_in_iterable()</code></li> <li><code>is_in()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>@typechecked\ndef is_value_in_iterable(\n    value: scalar,\n    iterable: any_collection,\n) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check if a given value is present in an iterable.\n\n    ???+ info \"Details\"\n        This function is used to verify if a given value exists within an iterable such as a list, tuple, or set.\n\n    Params:\n        value (scalar):\n            The value to check.\n        iterable (any_collection):\n            The iterable to check within.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (bool):\n            `#!py True` if the value is found in the iterable; `#!py False` otherwise.\n\n    ???+ example \"Examples\"\n\n        Check if a value is in an iterable:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import is_value_in_iterable\n        &gt;&gt;&gt; value = 2\n        &gt;&gt;&gt; iterable = [1, 2, 3]\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check if value is in the iterable\"}\n        &gt;&gt;&gt; is_value_in_iterable(value, iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        True\n        ```\n        !!! success \"Conclusion: The value is in the iterable.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check if value is not in the iterable\"}\n        &gt;&gt;&gt; is_value_in_iterable(4, iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        False\n        ```\n        !!! failure \"Conclusion: The value is not in the iterable.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_in_iterable()`][toolbox_python.checkers.is_value_in_iterable]\n        - [`is_in()`][toolbox_python.checkers.is_in]\n    \"\"\"\n    return value in iterable\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_all_values_in_iterable","title":"is_all_values_in_iterable","text":"<pre><code>is_all_values_in_iterable(\n    values: any_collection, iterable: any_collection\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check if all values in an iterable are present in another iterable.</p> Details <p>This function is used to verify if all values in a given iterable exist within another iterable.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>any_collection</code> <p>The iterable containing values to check.</p> required <code>iterable</code> <code>any_collection</code> <p>The iterable to check within.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all values are found in the iterable; <code>False</code> otherwise.</p> Examples <p>Check if all values in an iterable are present in another iterable:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import is_all_values_in_iterable\n&gt;&gt;&gt; values = [1, 2]\n&gt;&gt;&gt; iterable = [1, 2, 3]\n</code></pre> <p>Example 1: Check if all values are in the iterable<pre><code>&gt;&gt;&gt; is_all_values_in_iterable(values, iterable)\n</code></pre> Output<pre><code>True\n</code></pre> <p>Conclusion: All values are in the iterable.</p> <p>Example 2: Check if all values are not in the iterable<pre><code>&gt;&gt;&gt; is_all_values_in_iterable([1, 4], iterable)\n</code></pre> Output<pre><code>False\n</code></pre> <p>Conclusion: Not all values are in the iterable.</p> See Also <ul> <li><code>is_value_in_iterable()</code></li> <li><code>is_all_values_of_type()</code></li> <li><code>is_in()</code></li> <li><code>is_all_in()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>@typechecked\ndef is_all_values_in_iterable(\n    values: any_collection,\n    iterable: any_collection,\n) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check if all values in an iterable are present in another iterable.\n\n    ???+ info \"Details\"\n        This function is used to verify if all values in a given iterable exist within another iterable.\n\n    Params:\n        values (any_collection):\n            The iterable containing values to check.\n        iterable (any_collection):\n            The iterable to check within.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (bool):\n            `#!py True` if all values are found in the iterable; `#!py False` otherwise.\n\n    ???+ example \"Examples\"\n\n        Check if all values in an iterable are present in another iterable:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import is_all_values_in_iterable\n        &gt;&gt;&gt; values = [1, 2]\n        &gt;&gt;&gt; iterable = [1, 2, 3]\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check if all values are in the iterable\"}\n        &gt;&gt;&gt; is_all_values_in_iterable(values, iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        True\n        ```\n        !!! success \"Conclusion: All values are in the iterable.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check if all values are not in the iterable\"}\n        &gt;&gt;&gt; is_all_values_in_iterable([1, 4], iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        False\n        ```\n        !!! failure \"Conclusion: Not all values are in the iterable.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_in_iterable()`][toolbox_python.checkers.is_value_in_iterable]\n        - [`is_all_values_of_type()`][toolbox_python.checkers.is_all_values_of_type]\n        - [`is_in()`][toolbox_python.checkers.is_in]\n        - [`is_all_in()`][toolbox_python.checkers.is_all_in]\n    \"\"\"\n    return all(value in iterable for value in values)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_any_values_in_iterable","title":"is_any_values_in_iterable","text":"<pre><code>is_any_values_in_iterable(\n    values: any_collection, iterable: any_collection\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check if any value in an iterable is present in another iterable.</p> Details <p>This function is used to verify if any value in a given iterable exists within another iterable.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>any_collection</code> <p>The iterable containing values to check.</p> required <code>iterable</code> <code>any_collection</code> <p>The iterable to check within.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if any value is found in the iterable; <code>False</code> otherwise.</p> Examples <p>Check if any value in an iterable is present in another iterable:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import is_any_values_in_iterable\n&gt;&gt;&gt; values = [1, 4]\n&gt;&gt;&gt; iterable = [1, 2, 3]\n</code></pre> <p>Example 1: Check if any value is in the iterable<pre><code>&gt;&gt;&gt; is_any_values_in_iterable(values, iterable)\n</code></pre> Output<pre><code>True\n</code></pre> <p>Conclusion: At least one value is in the iterable.</p> <p>Example 2: Check if any value is not in the iterable<pre><code>&gt;&gt;&gt; is_any_values_in_iterable([4, 5], iterable)\n</code></pre> Output<pre><code>False\n</code></pre> <p>Conclusion: None of the values are in the iterable.</p> See Also <ul> <li><code>is_value_in_iterable()</code></li> <li><code>is_any_values_of_type()</code></li> <li><code>is_in()</code></li> <li><code>is_any_in()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>@typechecked\ndef is_any_values_in_iterable(\n    values: any_collection,\n    iterable: any_collection,\n) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check if any value in an iterable is present in another iterable.\n\n    ???+ info \"Details\"\n        This function is used to verify if any value in a given iterable exists within another iterable.\n\n    Params:\n        values (any_collection):\n            The iterable containing values to check.\n        iterable (any_collection):\n            The iterable to check within.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (bool):\n            `#!py True` if any value is found in the iterable; `#!py False` otherwise.\n\n    ???+ example \"Examples\"\n\n        Check if any value in an iterable is present in another iterable:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import is_any_values_in_iterable\n        &gt;&gt;&gt; values = [1, 4]\n        &gt;&gt;&gt; iterable = [1, 2, 3]\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check if any value is in the iterable\"}\n        &gt;&gt;&gt; is_any_values_in_iterable(values, iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        True\n        ```\n        !!! success \"Conclusion: At least one value is in the iterable.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check if any value is not in the iterable\"}\n        &gt;&gt;&gt; is_any_values_in_iterable([4, 5], iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        False\n        ```\n        !!! failure \"Conclusion: None of the values are in the iterable.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_in_iterable()`][toolbox_python.checkers.is_value_in_iterable]\n        - [`is_any_values_of_type()`][toolbox_python.checkers.is_any_values_of_type]\n        - [`is_in()`][toolbox_python.checkers.is_in]\n        - [`is_any_in()`][toolbox_python.checkers.is_any_in]\n    \"\"\"\n    return any(value in iterable for value in values)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_valid_value","title":"is_valid_value","text":"<pre><code>is_valid_value(value: Any, op: str, target: Any) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check if a value is valid based on a specified operator and target.</p> Details <p>This function checks if a given value meets a condition defined by an operator when compared to a target value. The operator can be one of the predefined operators in the <code>OPERATORS</code> dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <code>op</code> <code>str</code> <p>The operator to use for comparison. Valid operators are defined in the <code>OPERATORS</code> dictionary.</p> required <code>target</code> <code>Any</code> <p>The target value to compare against.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator is not recognized or is not valid.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the value meets the condition defined by the operator and target; <code>False</code> otherwise.</p> Examples <p>Check if a value is valid based on an operator and target:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import is_valid_value\n</code></pre> <p>Example 1: Check if value is greater than target<pre><code>&gt;&gt;&gt; is_valid_value(5, \"&gt;\", 3)\n</code></pre> Output<pre><code>True\n</code></pre> <p>Conclusion: The value is greater than the target.</p> <p>Example 2: Check if value is less than or equal to target<pre><code>&gt;&gt;&gt; is_valid_value(5, \"&lt;=\", 3)\n</code></pre> Output<pre><code>False\n</code></pre> <p>Conclusion: The value is not less than or equal to the target.</p> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def is_valid_value(value: Any, op: str, target: Any) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check if a value is valid based on a specified operator and target.\n\n    ???+ info \"Details\"\n        This function checks if a given value meets a condition defined by an operator when compared to a target value. The operator can be one of the predefined operators in the [`OPERATORS`][toolbox_python.checkers.OPERATORS] dictionary.\n\n    Params:\n        value (Any):\n            The value to check.\n        op (str):\n            The operator to use for comparison. Valid operators are defined in the [`OPERATORS`][toolbox_python.checkers.OPERATORS] dictionary.\n        target (Any):\n            The target value to compare against.\n\n    Raises:\n        ValueError:\n            If the operator is not recognized or is not valid.\n\n    Returns:\n        (bool):\n            `#!py True` if the value meets the condition defined by the operator and target; `#!py False` otherwise.\n\n    ???+ example \"Examples\"\n\n        Check if a value is valid based on an operator and target:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import is_valid_value\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check if value is greater than target\"}\n        &gt;&gt;&gt; is_valid_value(5, \"&gt;\", 3)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        True\n        ```\n        !!! success \"Conclusion: The value is greater than the target.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check if value is less than or equal to target\"}\n        &gt;&gt;&gt; is_valid_value(5, \"&lt;=\", 3)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        False\n        ```\n        !!! failure \"Conclusion: The value is not less than or equal to the target.\"\n        &lt;/div&gt;\n    \"\"\"\n    if op not in OPERATORS:\n        raise ValueError(\n            f\"Unknown operator '{op}'. Valid operators are: {list(OPERATORS.keys())}\"\n        )\n    op_func: Callable[[Any, Any], bool] = OPERATORS[op]\n    return op_func(value, target)\n</code></pre>"},{"location":"code/checkers/#is_-function-aliases","title":"<code>is_*()</code> function aliases","text":"<p>Summary</p> <p>This module provides functions to check certain values against other objects. It includes type checking, value validation, and membership checks.</p>"},{"location":"code/checkers/#toolbox_python.checkers.is_type","title":"is_type  <code>module-attribute</code>","text":"<pre><code>is_type = is_value_of_type\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_all_type","title":"is_all_type  <code>module-attribute</code>","text":"<pre><code>is_all_type = is_all_values_of_type\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_any_type","title":"is_any_type  <code>module-attribute</code>","text":"<pre><code>is_any_type = is_any_values_of_type\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_in","title":"is_in  <code>module-attribute</code>","text":"<pre><code>is_in = is_value_in_iterable\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_any_in","title":"is_any_in  <code>module-attribute</code>","text":"<pre><code>is_any_in = is_any_values_in_iterable\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_all_in","title":"is_all_in  <code>module-attribute</code>","text":"<pre><code>is_all_in = is_all_values_in_iterable\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.is_valid","title":"is_valid  <code>module-attribute</code>","text":"<pre><code>is_valid = is_valid_value\n</code></pre>"},{"location":"code/checkers/#assert_-functions","title":"<code>assert_*()</code> functions","text":"<p>Summary</p> <p>This module provides functions to check certain values against other objects. It includes type checking, value validation, and membership checks.</p>"},{"location":"code/checkers/#toolbox_python.checkers.assert_value_of_type","title":"assert_value_of_type","text":"<pre><code>assert_value_of_type(\n    value: Any, check_type: Union[type, tuple[type, ...]]\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Assert that a given value is of a specified type or types.</p> Details <p>This function is used to assert that a given value matches a specified type or any of the types in a tuple of types. If the value does not match the specified type(s), a <code>TypeError</code> is raised.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <code>check_type</code> <code>Union[type, tuple[type]]</code> <p>The type or tuple of types to check against.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value is not of the specified type or one of the specified types.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value. It raises an exception if the assertion fails.</p> Examples <p>Assert that a value is of a specific type:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import assert_value_of_type\n&gt;&gt;&gt; value = 42\n&gt;&gt;&gt; check_type = int\n</code></pre> <p>Example 1: Assert that value is of type int<pre><code>&gt;&gt;&gt; assert_value_of_type(value, check_type)\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: The value is of type <code>int</code>.</p> <p>Example 2: Assert that value is of type str<pre><code>&gt;&gt;&gt; assert_value_of_type(value, str)\n</code></pre> Output<pre><code>TypeError: Value '42' is not correct type: 'int'. Must be: 'str'\n</code></pre> <p>Conclusion: The value is not of type <code>str</code>.</p> <p>Example 3: Assert that value is of type int or float<pre><code>&gt;&gt;&gt; assert_value_of_type(value, (int, float))\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: The value is of type <code>int</code> or <code>float</code>.</p> <p>Example 4: Assert that value is of type str or dict<pre><code>&gt;&gt;&gt; assert_value_of_type(value, (str, dict))\n</code></pre> Output<pre><code>TypeError: Value '42' is not correct type: 'int'. Must be: 'str' or 'dict'.\n</code></pre> <p>Conclusion: The value is not of type <code>str</code> or <code>dict</code>.</p> See Also <ul> <li><code>is_value_of_type()</code></li> <li><code>is_type()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def assert_value_of_type(\n    value: Any,\n    check_type: Union[type, tuple[type, ...]],\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Assert that a given value is of a specified type or types.\n\n    ???+ info \"Details\"\n        This function is used to assert that a given value matches a specified type or any of the types in a tuple of types. If the value does not match the specified type(s), a `#!py TypeError` is raised.\n\n    Params:\n        value (Any):\n            The value to check.\n        check_type (Union[type, tuple[type]]):\n            The type or tuple of types to check against.\n\n    Raises:\n        TypeError:\n            If the value is not of the specified type or one of the specified types.\n\n    Returns:\n        (None):\n            This function does not return a value. It raises an exception if the assertion fails.\n\n    ???+ example \"Examples\"\n\n        Assert that a value is of a specific type:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import assert_value_of_type\n        &gt;&gt;&gt; value = 42\n        &gt;&gt;&gt; check_type = int\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Assert that value is of type int\"}\n        &gt;&gt;&gt; assert_value_of_type(value, check_type)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: The value is of type `#!py int`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Assert that value is of type str\"}\n        &gt;&gt;&gt; assert_value_of_type(value, str)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        TypeError: Value '42' is not correct type: 'int'. Must be: 'str'\n        ```\n        !!! failure \"Conclusion: The value is not of type `#!py str`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Assert that value is of type int or float\"}\n        &gt;&gt;&gt; assert_value_of_type(value, (int, float))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: The value is of type `#!py int` or `#!py float`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Assert that value is of type str or dict\"}\n        &gt;&gt;&gt; assert_value_of_type(value, (str, dict))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        TypeError: Value '42' is not correct type: 'int'. Must be: 'str' or 'dict'.\n        ```\n        !!! failure \"Conclusion: The value is not of type `#!py str` or `#!py dict`.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_of_type()`][toolbox_python.checkers.is_value_of_type]\n        - [`is_type()`][toolbox_python.checkers.is_type]\n    \"\"\"\n    if not is_type(value=value, check_type=check_type):\n        msg: str = f\"Value '{value}' is not correct type: '{type(value).__name__}'. \"\n        if isinstance(check_type, type):\n            msg += f\"Must be: '{check_type.__name__}'.\"\n        else:\n            msg += f\"Must be: '{' or '.join([typ.__name__ for typ in check_type])}'.\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_all_values_of_type","title":"assert_all_values_of_type","text":"<pre><code>assert_all_values_of_type(\n    values: any_collection,\n    check_type: Union[type, tuple[type, ...]],\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Assert that all values in an iterable are of a specified type or types.</p> Details <p>This function is used to assert that all values in a given iterable match a specified type or any of the types in a tuple of types. If any value does not match the specified type(s), a <code>TypeError</code> is raised.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>any_collection</code> <p>The iterable containing values to check.</p> required <code>check_type</code> <code>Union[type, tuple[type]]</code> <p>The type or tuple of types to check against.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If any value is not of the specified type or one of the specified types.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value. It raises an exception if the assertion fails.</p> Examples <p>Assert that all values in an iterable are of a specific type:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import assert_all_values_of_type\n&gt;&gt;&gt; values = [1, 2, 3]\n&gt;&gt;&gt; check_type = int\n</code></pre> <p>Example 1: Assert that all values are of type int<pre><code>&gt;&gt;&gt; assert_all_values_of_type(values, check_type)\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: All values are of type <code>int</code>.</p> <p>Example 2: Assert that all values are of type str<pre><code>&gt;&gt;&gt; assert_all_values_of_type(values, str)\n</code></pre> Output<pre><code>TypeError: Some elements [1, 2, 3] have the incorrect type ['int', 'int', 'int']. Must be 'str'\n</code></pre> <p>Conclusion: Not all values are of type <code>str</code>.</p> <p>Example 3: Assert that all values are of type int or float<pre><code>&gt;&gt;&gt; assert_all_values_of_type(values, (int, float))\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: All values are of type <code>int</code> or <code>float</code>.</p> <p>Example 4: Assert that all values are of type str or dict<pre><code>&gt;&gt;&gt; assert_all_values_of_type(values, (str, dict))\n</code></pre> Output<pre><code>TypeError: Some elements [1, 2, 3] have the incorrect type ['int', 'int', 'int']. Must be: 'str' or 'dict'\n</code></pre> <p>Conclusion: Not all values are of type <code>str</code> or <code>dict</code>.</p> See Also <ul> <li><code>is_value_of_type()</code></li> <li><code>is_all_values_of_type()</code></li> <li><code>is_type()</code></li> <li><code>is_all_type()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def assert_all_values_of_type(\n    values: any_collection,\n    check_type: Union[type, tuple[type, ...]],\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Assert that all values in an iterable are of a specified type or types.\n\n    ???+ info \"Details\"\n        This function is used to assert that all values in a given iterable match a specified type or any of the types in a tuple of types. If any value does not match the specified type(s), a `#!py TypeError` is raised.\n\n    Params:\n        values (any_collection):\n            The iterable containing values to check.\n        check_type (Union[type, tuple[type]]):\n            The type or tuple of types to check against.\n\n    Raises:\n        TypeError:\n            If any value is not of the specified type or one of the specified types.\n\n    Returns:\n        (None):\n            This function does not return a value. It raises an exception if the assertion fails.\n\n    ???+ example \"Examples\"\n\n        Assert that all values in an iterable are of a specific type:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import assert_all_values_of_type\n        &gt;&gt;&gt; values = [1, 2, 3]\n        &gt;&gt;&gt; check_type = int\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Assert that all values are of type int\"}\n        &gt;&gt;&gt; assert_all_values_of_type(values, check_type)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: All values are of type `#!py int`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Assert that all values are of type str\"}\n        &gt;&gt;&gt; assert_all_values_of_type(values, str)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        TypeError: Some elements [1, 2, 3] have the incorrect type ['int', 'int', 'int']. Must be 'str'\n        ```\n        !!! failure \"Conclusion: Not all values are of type `#!py str`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Assert that all values are of type int or float\"}\n        &gt;&gt;&gt; assert_all_values_of_type(values, (int, float))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: All values are of type `#!py int` or `#!py float`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Assert that all values are of type str or dict\"}\n        &gt;&gt;&gt; assert_all_values_of_type(values, (str, dict))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        TypeError: Some elements [1, 2, 3] have the incorrect type ['int', 'int', 'int']. Must be: 'str' or 'dict'\n        ```\n        !!! failure \"Conclusion: Not all values are of type `#!py str` or `#!py dict`.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_of_type()`][toolbox_python.checkers.is_value_of_type]\n        - [`is_all_values_of_type()`][toolbox_python.checkers.is_all_values_of_type]\n        - [`is_type()`][toolbox_python.checkers.is_type]\n        - [`is_all_type()`][toolbox_python.checkers.is_all_type]\n    \"\"\"\n    if not is_all_type(values=values, check_type=check_type):\n        invalid_values = [value for value in values if not is_type(value, check_type)]\n        invalid_types = [\n            f\"'{type(value).__name__}'\"\n            for value in values\n            if not is_type(value, check_type)\n        ]\n        msg: str = (\n            f\"Some elements {invalid_values} have the incorrect type {invalid_types}. \"\n        )\n        if isinstance(check_type, type):\n            msg += f\"Must be '{check_type}'\"\n        else:\n            types: str_list = [f\"'{typ.__name__}'\" for typ in check_type]\n            msg += f\"Must be: {' or '.join(types)}\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_any_values_of_type","title":"assert_any_values_of_type","text":"<pre><code>assert_any_values_of_type(\n    values: any_collection,\n    check_type: Union[type, tuple[type, ...]],\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Assert that any value in an iterable is of a specified type or types.</p> Details <p>This function is used to assert that at least one value in a given iterable matches a specified type or any of the types in a tuple of types. If none of the values match the specified type(s), a <code>TypeError</code> is raised.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>any_collection</code> <p>The iterable containing values to check.</p> required <code>check_type</code> <code>Union[type, tuple[type]]</code> <p>The type or tuple of types to check against.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If none of the values are of the specified type or one of the specified types.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value. It raises an exception if the assertion fails.</p> Examples <p>Assert that any value in an iterable is of a specific type:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import assert_any_values_of_type\n&gt;&gt;&gt; values = [1, \"a\", 3.0]\n&gt;&gt;&gt; check_type = str\n</code></pre> <p>Example 1: Assert that any value is of type str<pre><code>&gt;&gt;&gt; assert_any_values_of_type(values, check_type)\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: At least one value is of type <code>str</code>.</p> <p>Example 2: Assert that any value is of type dict<pre><code>&gt;&gt;&gt; assert_any_values_of_type(values, dict)\n</code></pre> Output<pre><code>TypeError: None of the elements in [1, 'a', 3.0] have the correct type. Must be: 'dict'\n</code></pre> <p>Conclusion: None of the values are of type <code>dict</code>.</p> <p>Example 3: Assert that any value is of type int or float<pre><code>&gt;&gt;&gt; assert_any_values_of_type(values, (int, float))\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: At least one value is of type <code>int</code> or <code>float</code>.</p> <p>Example 4: Assert that any value is of type dict or list<pre><code>&gt;&gt;&gt; assert_any_values_of_type(values, (dict, list))\n</code></pre> Output<pre><code>TypeError: None of the elements in [1, 'a', 3.0] have the correct type. Must be: 'dict' or 'list'\n</code></pre> <p>Conclusion: None of the values are of type <code>dict</code> or <code>list</code>.</p> See Also <ul> <li><code>is_value_of_type()</code></li> <li><code>is_any_values_of_type()</code></li> <li><code>is_type()</code></li> <li><code>is_any_type()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def assert_any_values_of_type(\n    values: any_collection,\n    check_type: Union[type, tuple[type, ...]],\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Assert that any value in an iterable is of a specified type or types.\n\n    ???+ info \"Details\"\n        This function is used to assert that at least one value in a given iterable matches a specified type or any of the types in a tuple of types. If none of the values match the specified type(s), a `#!py TypeError` is raised.\n\n    Params:\n        values (any_collection):\n            The iterable containing values to check.\n        check_type (Union[type, tuple[type]]):\n            The type or tuple of types to check against.\n\n    Raises:\n        TypeError:\n            If none of the values are of the specified type or one of the specified types.\n\n    Returns:\n        (None):\n            This function does not return a value. It raises an exception if the assertion fails.\n\n    ???+ example \"Examples\"\n\n        Assert that any value in an iterable is of a specific type:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import assert_any_values_of_type\n        &gt;&gt;&gt; values = [1, \"a\", 3.0]\n        &gt;&gt;&gt; check_type = str\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Assert that any value is of type str\"}\n        &gt;&gt;&gt; assert_any_values_of_type(values, check_type)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: At least one value is of type `#!py str`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Assert that any value is of type dict\"}\n        &gt;&gt;&gt; assert_any_values_of_type(values, dict)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        TypeError: None of the elements in [1, 'a', 3.0] have the correct type. Must be: 'dict'\n        ```\n        !!! failure \"Conclusion: None of the values are of type `#!py dict`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Assert that any value is of type int or float\"}\n        &gt;&gt;&gt; assert_any_values_of_type(values, (int, float))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: At least one value is of type `#!py int` or `#!py float`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Assert that any value is of type dict or list\"}\n        &gt;&gt;&gt; assert_any_values_of_type(values, (dict, list))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        TypeError: None of the elements in [1, 'a', 3.0] have the correct type. Must be: 'dict' or 'list'\n        ```\n        !!! failure \"Conclusion: None of the values are of type `#!py dict` or `#!py list`.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_of_type()`][toolbox_python.checkers.is_value_of_type]\n        - [`is_any_values_of_type()`][toolbox_python.checkers.is_any_values_of_type]\n        - [`is_type()`][toolbox_python.checkers.is_type]\n        - [`is_any_type()`][toolbox_python.checkers.is_any_type]\n    \"\"\"\n    if not is_any_type(values=values, check_type=check_type):\n        invalid_values = [value for value in values if not is_type(value, check_type)]\n        msg: str = f\"None of the elements in {invalid_values} have the correct type. \"\n        if isinstance(check_type, type):\n            msg += f\"Must be: '{check_type.__name__}'\"\n        else:\n            types: str_list = [f\"'{typ.__name__}'\" for typ in check_type]\n            msg += f\"Must be: {' or '.join(types)}\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_value_in_iterable","title":"assert_value_in_iterable","text":"<pre><code>assert_value_in_iterable(\n    value: scalar, iterable: any_collection\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Assert that a given value is present in an iterable.</p> Details <p>This function is used to assert that a given value exists within an iterable such as a <code>list</code>, <code>tuple</code>, or <code>set</code>. If the value is not found in the iterable, a <code>LookupError</code> is raised.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>scalar</code> <p>The value to check.</p> required <code>iterable</code> <code>any_collection</code> <p>The iterable to check within.</p> required <p>Raises:</p> Type Description <code>LookupError</code> <p>If the value is not found in the iterable.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value. It raises an exception if the assertion fails.</p> Examples <p>Assert that a value is in an iterable:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import assert_value_in_iterable\n&gt;&gt;&gt; value = 2\n&gt;&gt;&gt; iterable = [1, 2, 3]\n</code></pre> <p>Example 1: Assert that value is in the iterable<pre><code>&gt;&gt;&gt; assert_value_in_iterable(value, iterable)\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: The value is in the iterable.</p> <p>Example 2: Assert that value is not in the iterable<pre><code>&gt;&gt;&gt; assert_value_in_iterable(4, iterable)\n</code></pre> Output<pre><code>LookupError: Value '4' not found in iterable: [1, 2, 3]\n</code></pre> <p>Conclusion: The value is not in the iterable.</p> See Also <ul> <li><code>is_value_in_iterable()</code></li> <li><code>is_in()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def assert_value_in_iterable(\n    value: scalar,\n    iterable: any_collection,\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Assert that a given value is present in an iterable.\n\n    ???+ info \"Details\"\n        This function is used to assert that a given value exists within an iterable such as a `#!py list`, `#!py tuple`, or `#!py set`. If the value is not found in the iterable, a `#!py LookupError` is raised.\n\n    Params:\n        value (scalar):\n            The value to check.\n        iterable (any_collection):\n            The iterable to check within.\n\n    Raises:\n        LookupError:\n            If the value is not found in the iterable.\n\n    Returns:\n        (None):\n            This function does not return a value. It raises an exception if the assertion fails.\n\n    ???+ example \"Examples\"\n\n        Assert that a value is in an iterable:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import assert_value_in_iterable\n        &gt;&gt;&gt; value = 2\n        &gt;&gt;&gt; iterable = [1, 2, 3]\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Assert that value is in the iterable\"}\n        &gt;&gt;&gt; assert_value_in_iterable(value, iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: The value is in the iterable.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Assert that value is not in the iterable\"}\n        &gt;&gt;&gt; assert_value_in_iterable(4, iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        LookupError: Value '4' not found in iterable: [1, 2, 3]\n        ```\n        !!! failure \"Conclusion: The value is not in the iterable.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_in_iterable()`][toolbox_python.checkers.is_value_in_iterable]\n        - [`is_in()`][toolbox_python.checkers.is_in]\n    \"\"\"\n    if not is_in(value=value, iterable=iterable):\n        raise LookupError(f\"Value '{value}' not found in iterable: {iterable}\")\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_any_values_in_iterable","title":"assert_any_values_in_iterable","text":"<pre><code>assert_any_values_in_iterable(\n    values: any_collection, iterable: any_collection\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Assert that any value in an iterable is present in another iterable.</p> Details <p>This function is used to assert that at least one value in a given iterable exists within another iterable. If none of the values are found in the iterable, a <code>LookupError</code> is raised.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>any_collection</code> <p>The iterable containing values to check.</p> required <code>iterable</code> <code>any_collection</code> <p>The iterable to check within.</p> required <p>Raises:</p> Type Description <code>LookupError</code> <p>If none of the values are found in the iterable.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value. It raises an exception if the assertion fails.</p> Examples <p>Assert that any value in an iterable is present in another iterable:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import assert_any_values_in_iterable\n&gt;&gt;&gt; values = [1, 4]\n&gt;&gt;&gt; iterable = [1, 2, 3]\n</code></pre> <p>Example 1: Assert that any value is in the iterable<pre><code>&gt;&gt;&gt; assert_any_values_in_iterable(values, iterable)\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: At least one value is in the iterable.</p> <p>Example 2: Assert that any value is not in the iterable<pre><code>&gt;&gt;&gt; assert_any_values_in_iterable([4, 5], iterable)\n</code></pre> Output<pre><code>LookupError: None of the values in [4, 5] can be found in [1, 2, 3]\n</code></pre> <p>Conclusion: None of the values are in the iterable.</p> See Also <ul> <li><code>is_value_in_iterable()</code></li> <li><code>is_any_values_of_type()</code></li> <li><code>is_in()</code></li> <li><code>is_any_in()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def assert_any_values_in_iterable(\n    values: any_collection,\n    iterable: any_collection,\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Assert that any value in an iterable is present in another iterable.\n\n    ???+ info \"Details\"\n        This function is used to assert that at least one value in a given iterable exists within another iterable. If none of the values are found in the iterable, a `#!py LookupError` is raised.\n\n    Params:\n        values (any_collection):\n            The iterable containing values to check.\n        iterable (any_collection):\n            The iterable to check within.\n\n    Raises:\n        LookupError:\n            If none of the values are found in the iterable.\n\n    Returns:\n        (None):\n            This function does not return a value. It raises an exception if the assertion fails.\n\n    ???+ example \"Examples\"\n\n        Assert that any value in an iterable is present in another iterable:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import assert_any_values_in_iterable\n        &gt;&gt;&gt; values = [1, 4]\n        &gt;&gt;&gt; iterable = [1, 2, 3]\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Assert that any value is in the iterable\"}\n        &gt;&gt;&gt; assert_any_values_in_iterable(values, iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: At least one value is in the iterable.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Assert that any value is not in the iterable\"}\n        &gt;&gt;&gt; assert_any_values_in_iterable([4, 5], iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        LookupError: None of the values in [4, 5] can be found in [1, 2, 3]\n        ```\n        !!! failure \"Conclusion: None of the values are in the iterable.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_in_iterable()`][toolbox_python.checkers.is_value_in_iterable]\n        - [`is_any_values_of_type()`][toolbox_python.checkers.is_any_values_of_type]\n        - [`is_in()`][toolbox_python.checkers.is_in]\n        - [`is_any_in()`][toolbox_python.checkers.is_any_in]\n    \"\"\"\n    if not is_any_in(values=values, iterable=iterable):\n        raise LookupError(f\"None of the values in {values} can be found in {iterable}\")\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_all_values_in_iterable","title":"assert_all_values_in_iterable","text":"<pre><code>assert_all_values_in_iterable(\n    values: any_collection, iterable: any_collection\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Assert that all values in an iterable are present in another iterable.</p> Details <p>This function is used to assert that all values in a given iterable exist within another iterable. If any value is not found in the iterable, a <code>LookupError</code> is raised.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>any_collection</code> <p>The iterable containing values to check.</p> required <code>iterable</code> <code>any_collection</code> <p>The iterable to check within.</p> required <p>Raises:</p> Type Description <code>LookupError</code> <p>If any value is not found in the iterable.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value. It raises an exception if the assertion fails.</p> Examples <p>Assert that all values in an iterable are present in another iterable:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import assert_all_values_in_iterable\n&gt;&gt;&gt; values = [1, 2]\n&gt;&gt;&gt; iterable = [1, 2, 3]\n</code></pre> <p>Example 1: Assert that all values are in the iterable<pre><code>&gt;&gt;&gt; assert_all_values_in_iterable(values, iterable)\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: All values are in the iterable.</p> <p>Example 2: Assert that all values are not in the iterable<pre><code>&gt;&gt;&gt; assert_all_values_in_iterable([1, 4], iterable)\n</code></pre> Output<pre><code>LookupError: Some values [4] are missing from [1, 2, 3]\n</code></pre> <p>Conclusion: Not all values are in the iterable.</p> See Also <ul> <li><code>is_value_in_iterable()</code></li> <li><code>is_all_values_of_type()</code></li> <li><code>is_in()</code></li> <li><code>is_all_in()</code></li> </ul> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def assert_all_values_in_iterable(\n    values: any_collection,\n    iterable: any_collection,\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Assert that all values in an iterable are present in another iterable.\n\n    ???+ info \"Details\"\n        This function is used to assert that all values in a given iterable exist within another iterable. If any value is not found in the iterable, a `#!py LookupError` is raised.\n\n    Params:\n        values (any_collection):\n            The iterable containing values to check.\n        iterable (any_collection):\n            The iterable to check within.\n\n    Raises:\n        LookupError:\n            If any value is not found in the iterable.\n\n    Returns:\n        (None):\n            This function does not return a value. It raises an exception if the assertion fails.\n\n    ???+ example \"Examples\"\n\n        Assert that all values in an iterable are present in another iterable:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import assert_all_values_in_iterable\n        &gt;&gt;&gt; values = [1, 2]\n        &gt;&gt;&gt; iterable = [1, 2, 3]\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Assert that all values are in the iterable\"}\n        &gt;&gt;&gt; assert_all_values_in_iterable(values, iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: All values are in the iterable.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Assert that all values are not in the iterable\"}\n        &gt;&gt;&gt; assert_all_values_in_iterable([1, 4], iterable)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        LookupError: Some values [4] are missing from [1, 2, 3]\n        ```\n        !!! failure \"Conclusion: Not all values are in the iterable.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`is_value_in_iterable()`][toolbox_python.checkers.is_value_in_iterable]\n        - [`is_all_values_of_type()`][toolbox_python.checkers.is_all_values_of_type]\n        - [`is_in()`][toolbox_python.checkers.is_in]\n        - [`is_all_in()`][toolbox_python.checkers.is_all_in]\n    \"\"\"\n    if not is_all_in(values=values, iterable=iterable):\n        missing_values = [value for value in values if not is_in(value, iterable)]\n        raise LookupError(f\"Some values {missing_values} are missing from {iterable}\")\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_is_valid_value","title":"assert_is_valid_value","text":"<pre><code>assert_is_valid_value(\n    value: Any, op: str, target: Any\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Assert that a value is valid based on a specified operator and target.</p> Details <p>This function checks if a given value meets a condition defined by an operator when compared to a target value. The operator can be one of the predefined operators in the <code>OPERATORS</code> dictionary. If the condition is not met, a <code>ValueError</code> is raised.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <code>op</code> <code>str</code> <p>The operator to use for comparison. Valid operators are defined in the <code>OPERATORS</code> dictionary.</p> required <code>target</code> <code>Any</code> <p>The target value to compare against.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operator is not recognized or if the value does not meet the condition defined by the operator and target.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value. It raises an exception if the condition is not met.</p> Examples <p>Assert that a value is valid based on an operator and target:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import assert_is_valid_value\n</code></pre> <p>Example 1: Assert that value is greater than target<pre><code>&gt;&gt;&gt; assert_is_valid_value(5, \"&gt;\", 3)\n</code></pre> Output<pre><code>(no output, no exception raised)\n</code></pre> <p>Conclusion: The value is greater than the target.</p> <p>Example 2: Assert that value is less than or equal to target<pre><code>&gt;&gt;&gt; assert_is_valid_value(5, \"&lt;=\", 3)\n</code></pre> Output<pre><code>ValueError: Validation failed: '5 &lt;= 3' is not True\n</code></pre> <p>Conclusion: The value is not less than or equal to the target.</p> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>def assert_is_valid_value(value: Any, op: str, target: Any) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Assert that a value is valid based on a specified operator and target.\n\n    ???+ info \"Details\"\n        This function checks if a given value meets a condition defined by an operator when compared to a target value. The operator can be one of the predefined operators in the [`OPERATORS`][toolbox_python.checkers.OPERATORS] dictionary. If the condition is not met, a `#!py ValueError` is raised.\n\n    Params:\n        value (Any):\n            The value to check.\n        op (str):\n            The operator to use for comparison. Valid operators are defined in the [`OPERATORS`][toolbox_python.checkers.OPERATORS] dictionary.\n        target (Any):\n            The target value to compare against.\n\n    Raises:\n        ValueError:\n            If the operator is not recognized or if the value does not meet the condition defined by the operator and target.\n\n    Returns:\n        (None):\n            This function does not return a value. It raises an exception if the condition is not met.\n\n    ???+ example \"Examples\"\n\n        Assert that a value is valid based on an operator and target:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import assert_is_valid_value\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Assert that value is greater than target\"}\n        &gt;&gt;&gt; assert_is_valid_value(5, \"&gt;\", 3)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        (no output, no exception raised)\n        ```\n        !!! success \"Conclusion: The value is greater than the target.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Assert that value is less than or equal to target\"}\n        &gt;&gt;&gt; assert_is_valid_value(5, \"&lt;=\", 3)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        ValueError: Validation failed: '5 &lt;= 3' is not True\n        ```\n        !!! failure \"Conclusion: The value is not less than or equal to the target.\"\n        &lt;/div&gt;\n    \"\"\"\n    if not is_valid_value(value, op, target):\n        raise ValueError(f\"Validation failed: '{value} {op} {target}' is not True\")\n</code></pre>"},{"location":"code/checkers/#assert_-function-aliases","title":"<code>assert_*()</code> function aliases","text":"<p>Summary</p> <p>This module provides functions to check certain values against other objects. It includes type checking, value validation, and membership checks.</p>"},{"location":"code/checkers/#toolbox_python.checkers.assert_type","title":"assert_type  <code>module-attribute</code>","text":"<pre><code>assert_type = assert_value_of_type\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_is_type","title":"assert_is_type  <code>module-attribute</code>","text":"<pre><code>assert_is_type = assert_value_of_type\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_all_type","title":"assert_all_type  <code>module-attribute</code>","text":"<pre><code>assert_all_type = assert_all_values_of_type\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_all_is_type","title":"assert_all_is_type  <code>module-attribute</code>","text":"<pre><code>assert_all_is_type = assert_all_values_of_type\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_any_type","title":"assert_any_type  <code>module-attribute</code>","text":"<pre><code>assert_any_type = assert_any_values_of_type\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_any_is_type","title":"assert_any_is_type  <code>module-attribute</code>","text":"<pre><code>assert_any_is_type = assert_any_values_of_type\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_in","title":"assert_in  <code>module-attribute</code>","text":"<pre><code>assert_in = assert_value_in_iterable\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_any_in","title":"assert_any_in  <code>module-attribute</code>","text":"<pre><code>assert_any_in = assert_any_values_in_iterable\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_all_in","title":"assert_all_in  <code>module-attribute</code>","text":"<pre><code>assert_all_in = assert_all_values_in_iterable\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.assert_is_valid","title":"assert_is_valid  <code>module-attribute</code>","text":"<pre><code>assert_is_valid = assert_is_valid_value\n</code></pre>"},{"location":"code/checkers/#_contains-functions","title":"<code>*_contains()</code> functions","text":"<p>Summary</p> <p>This module provides functions to check certain values against other objects. It includes type checking, value validation, and membership checks.</p>"},{"location":"code/checkers/#toolbox_python.checkers.any_element_contains","title":"any_element_contains","text":"<pre><code>any_element_contains(\n    iterable: str_collection, check: str\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check to see if any element in a given iterable contains a given string value.</p> <p>Note: This check is case sensitive.</p> Details <p>This function is helpful for doing a quick check to see if any element in a <code>list</code> contains a given <code>str</code> value. For example, checking if any column header contains a specific string value.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>str_collection</code> <p>The iterables to check within. Because this function uses an <code>in</code> operation to check if <code>check</code> string exists in the elements of <code>iterable</code>, therefore all elements of <code>iterable</code> must be <code>str</code> type.</p> required <code>check</code> <code>str</code> <p>The string value to check exists in any of the elements in <code>iterable</code>.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if at least one element in <code>iterable</code> contains <code>check</code> string; <code>False</code> if no elements contain <code>check</code>.</p> Examples <p>Check if any element in an iterable contains a specific string:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import any_element_contains\n&gt;&gt;&gt; iterable = [\"apple\", \"banana\", \"cherry\"]\n&gt;&gt;&gt; check = \"an\"\n</code></pre> <p>Example 1: Check if any element contains 'an'<pre><code>&gt;&gt;&gt; any_element_contains(iterable, check)\n</code></pre> Output<pre><code>True\n</code></pre> <p>Conclusion: At least one element contains <code>'an'</code>.</p> <p>Example 2: Check if any element contains 'xy'<pre><code>&gt;&gt;&gt; any_element_contains(iterable, \"xy\")\n</code></pre> Output<pre><code>False\n</code></pre> <p>Conclusion: No elements contain <code>'xy'</code>.</p> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>@typechecked\ndef any_element_contains(\n    iterable: str_collection,\n    check: str,\n) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check to see if any element in a given iterable contains a given string value.\n        !!! warning \"Note: This check _is_ case sensitive.\"\n\n    ???+ abstract \"Details\"\n        This function is helpful for doing a quick check to see if any element in a `#!py list` contains a given `#!py str` value. For example, checking if any column header contains a specific string value.\n\n    Params:\n        iterable (str_collection):\n            The iterables to check within. Because this function uses an `#!py in` operation to check if `check` string exists in the elements of `iterable`, therefore all elements of `iterable` must be `#!py str` type.\n        check (str):\n            The string value to check exists in any of the elements in `iterable`.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (bool):\n            `#!py True` if at least one element in `iterable` contains `check` string; `#!py False` if no elements contain `check`.\n\n    ???+ example \"Examples\"\n\n        Check if any element in an iterable contains a specific string:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import any_element_contains\n        &gt;&gt;&gt; iterable = [\"apple\", \"banana\", \"cherry\"]\n        &gt;&gt;&gt; check = \"an\"\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check if any element contains 'an'\"}\n        &gt;&gt;&gt; any_element_contains(iterable, check)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        True\n        ```\n        !!! success \"Conclusion: At least one element contains `'an'`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check if any element contains 'xy'\"}\n        &gt;&gt;&gt; any_element_contains(iterable, \"xy\")\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        False\n        ```\n        !!! failure \"Conclusion: No elements contain `'xy'`.\"\n        &lt;/div&gt;\n    \"\"\"\n    return any(check in elem for elem in iterable)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.all_elements_contains","title":"all_elements_contains","text":"<pre><code>all_elements_contains(\n    iterable: str_collection, check: str\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check to see if all elements in a given iterable contains a given string value.</p> <p>Note: This check is case sensitive.</p> Details <p>This function is helpful for doing a quick check to see if all element in a <code>list</code> contains a given <code>str</code> value. For example, checking if all columns in a DataFrame contains a specific string value.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>str_collection</code> <p>The iterables to check within. Because this function uses an <code>in</code> operation to check if <code>check</code> string exists in the elements of <code>iterable</code>, therefore all elements of <code>iterable</code> must be <code>str</code> type.</p> required <code>check</code> <code>str</code> <p>The string value to check exists in any of the elements in <code>iterable</code>.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if all elements in <code>iterable</code> contains <code>check</code> string; <code>False</code> otherwise.</p> Examples <p>Check if all elements in an iterable contain a specific string:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import all_elements_contains\n&gt;&gt;&gt; iterable = [\"apple\", \"banana\", \"peach\"]\n&gt;&gt;&gt; check = \"a\"\n</code></pre> <p>Example 1: Check if all elements contain 'a'<pre><code>&gt;&gt;&gt; all_elements_contains(iterable, check)\n</code></pre> Output<pre><code>True\n</code></pre> <p>Conclusion: All elements contain <code>'a'</code>.</p> <p>Example 2: Check if all elements contain 'e'<pre><code>&gt;&gt;&gt; all_elements_contains(iterable, \"e\")\n</code></pre> Output<pre><code>False\n</code></pre> <p>Conclusion: Not all elements contain <code>'e'</code>.</p> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>@typechecked\ndef all_elements_contains(iterable: str_collection, check: str) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check to see if all elements in a given iterable contains a given string value.\n        !!! warning \"Note: This check _is_ case sensitive.\"\n\n    ???+ abstract \"Details\"\n        This function is helpful for doing a quick check to see if all element in a `#!py list` contains a given `#!py str` value. For example, checking if all columns in a DataFrame contains a specific string value.\n\n    Params:\n        iterable (str_collection):\n            The iterables to check within. Because this function uses an `#!py in` operation to check if `check` string exists in the elements of `iterable`, therefore all elements of `iterable` must be `#!py str` type.\n        check (str):\n            The string value to check exists in any of the elements in `iterable`.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (bool):\n            `#!py True` if all elements in `iterable` contains `check` string; `#!py False` otherwise.\n\n    ???+ example \"Examples\"\n\n        Check if all elements in an iterable contain a specific string:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import all_elements_contains\n        &gt;&gt;&gt; iterable = [\"apple\", \"banana\", \"peach\"]\n        &gt;&gt;&gt; check = \"a\"\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check if all elements contain 'a'\"}\n        &gt;&gt;&gt; all_elements_contains(iterable, check)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        True\n        ```\n        !!! success \"Conclusion: All elements contain `'a'`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check if all elements contain 'e'\"}\n        &gt;&gt;&gt; all_elements_contains(iterable, \"e\")\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        False\n        ```\n        !!! failure \"Conclusion: Not all elements contain `'e'`.\"\n        &lt;/div&gt;\n    \"\"\"\n    return all(check in elem for elem in iterable)\n</code></pre>"},{"location":"code/checkers/#toolbox_python.checkers.get_elements_containing","title":"get_elements_containing","text":"<pre><code>get_elements_containing(\n    iterable: str_collection, check: str\n) -&gt; tuple[str, ...]\n</code></pre> <p>Summary</p> <p>Extract all elements in a given iterable which contains a given string value.</p> <p>Note: This check is case sensitive.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>str_collection</code> <p>The iterables to check within. Because this function uses an <code>in</code> operation to check if <code>check</code> string exists in the elements of <code>iterable</code>, therefore all elements of <code>iterable</code> must be <code>str</code> type.</p> required <code>check</code> <code>str</code> <p>The string value to check exists in any of the elements in <code>iterable</code>.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A <code>tuple</code> containing all the string elements from <code>iterable</code> which contains the <code>check</code> string.</p> Examples <p>Extract elements in an iterable that contain a specific string:</p> Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.checkers import get_elements_containing\n&gt;&gt;&gt; iterable = [\"apple\", \"banana\", \"cherry\"]\n&gt;&gt;&gt; check = \"an\"\n</code></pre> <p>Example 1: Extract elements containing 'an'<pre><code>&gt;&gt;&gt; get_elements_containing(iterable, check)\n</code></pre> Output<pre><code>('banana',)\n</code></pre> <p>Conclusion: The element(s) containing <code>'an'</code> are extracted.</p> <p>Example 2: Extract elements containing 'xy'<pre><code>&gt;&gt;&gt; get_elements_containing(iterable, \"xy\")\n</code></pre> Output<pre><code>()\n</code></pre> <p>Conclusion: No elements contain <code>'xy'</code>.</p> Source code in <code>src/toolbox_python/checkers.py</code> <pre><code>@typechecked\ndef get_elements_containing(iterable: str_collection, check: str) -&gt; tuple[str, ...]:\n    \"\"\"\n    !!! note \"Summary\"\n        Extract all elements in a given iterable which contains a given string value.\n        !!! warning \"Note: This check _is_ case sensitive.\"\n\n    Params:\n        iterable (str_collection):\n            The iterables to check within. Because this function uses an `#!py in` operation to check if `check` string exists in the elements of `iterable`, therefore all elements of `iterable` must be `#!py str` type.\n        check (str):\n            The string value to check exists in any of the elements in `iterable`.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (tuple):\n            A `#!py tuple` containing all the string elements from `iterable` which contains the `check` string.\n\n    ???+ example \"Examples\"\n\n        Extract elements in an iterable that contain a specific string:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.checkers import get_elements_containing\n        &gt;&gt;&gt; iterable = [\"apple\", \"banana\", \"cherry\"]\n        &gt;&gt;&gt; check = \"an\"\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Extract elements containing 'an'\"}\n        &gt;&gt;&gt; get_elements_containing(iterable, check)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        ('banana',)\n        ```\n        !!! success \"Conclusion: The element(s) containing `'an'` are extracted.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Extract elements containing 'xy'\"}\n        &gt;&gt;&gt; get_elements_containing(iterable, \"xy\")\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        ()\n        ```\n        !!! failure \"Conclusion: No elements contain `'xy'`.\"\n        &lt;/div&gt;\n    \"\"\"\n    return tuple(elem for elem in iterable if check in elem)\n</code></pre>"},{"location":"code/classes/","title":"Classes","text":""},{"location":"code/classes/#toolbox_python.classes","title":"toolbox_python.classes","text":"<p>Summary</p> <p>The <code>classes</code> module is designed for functions to be executed on classes; not within classes. For any methods/functions that should be added to classes, you should consider re-designing the original class, or sub-classing it to make further alterations.</p>"},{"location":"code/classes/#toolbox_python.classes.get_full_class_name","title":"get_full_class_name","text":"<pre><code>get_full_class_name(obj: Any) -&gt; str\n</code></pre> <p>Summary</p> <p>This function is designed to extract the full name of a class, including the name of the module from which it was loaded.</p> Details <p>Note, this is designed to retrieve the underlying class name of an object, not the instance name of an object. This is useful for debugging purposes, or for logging.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object for which you want to retrieve the full name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The full name of the class of the object.</p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.classes import get_full_class_name\n</code></pre> <p>Example 1: Check the name of a standard class<pre><code>&gt;&gt;&gt; print(get_full_class_name(str))\n</code></pre> Terminal<pre><code>str\n</code></pre> <p>Conclusion: Successful class name extraction.</p> <p>Example 2: Check the name of an imported class<pre><code>&gt;&gt;&gt; from random import Random\n&gt;&gt;&gt; print(get_full_class_name(Random))\n</code></pre> Terminal<pre><code>random.Random\n</code></pre> <p>Conclusion: Successful class name extraction.</p> Credit <p>Full credit goes to: https://stackoverflow.com/questions/18176602/how-to-get-the-name-of-an-exception-that-was-caught-in-python#answer-58045927</p> Source code in <code>src/toolbox_python/classes.py</code> <pre><code>def get_full_class_name(obj: Any) -&gt; str:\n    \"\"\"\n    !!! note \"Summary\"\n        This function is designed to extract the full name of a class, including the name of the module from which it was loaded.\n\n    ???+ abstract \"Details\"\n        Note, this is designed to retrieve the underlying _class name_ of an object, not the _instance name_ of an object. This is useful for debugging purposes, or for logging.\n\n    Params:\n        obj (Any):\n            The object for which you want to retrieve the full name.\n\n    Returns:\n        (str):\n            The full name of the class of the object.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.classes import get_full_class_name\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Check the name of a standard class\"}\n        &gt;&gt;&gt; print(get_full_class_name(str))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        str\n        ```\n        !!! success \"Conclusion: Successful class name extraction.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Check the name of an imported class\"}\n        &gt;&gt;&gt; from random import Random\n        &gt;&gt;&gt; print(get_full_class_name(Random))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        random.Random\n        ```\n        !!! success \"Conclusion: Successful class name extraction.\"\n        &lt;/div&gt;\n\n    ??? success \"Credit\"\n        Full credit goes to:&lt;br&gt;\n        https://stackoverflow.com/questions/18176602/how-to-get-the-name-of-an-exception-that-was-caught-in-python#answer-58045927\n    \"\"\"\n    module: str = obj.__class__.__module__\n    if module is None or module == str.__class__.__module__:\n        return obj.__class__.__name__\n    return module + \".\" + obj.__class__.__name__\n</code></pre>"},{"location":"code/classes/#toolbox_python.classes.class_property","title":"class_property","text":"<p>               Bases: <code>property</code></p> <p>Summary</p> <p>Similar to <code>property</code>, but allows class-level properties. That is, a property whose getter is like a <code>classmethod</code>.</p> Details <p>The wrapped method may explicitly use the <code>classmethod</code> decorator (which must become before this decorator), or the <code>classmethod</code> may be omitted (it is implicit through use of this decorator).</p> <p>Parameters:</p> Name Type Description Default <code>fget</code> <code>callable</code> <p>The function that computes the value of this property (in particular, the function when this is used as a decorator) a la <code>property</code>.</p> required <code>doc</code> <code>str</code> <p>The docstring for the property--by default inherited from the getter function.</p> <code>None</code> Examples <p>Normal usage is as a decorator:</p> <p>Example 1: Normal usage<pre><code>&gt;&gt;&gt; class Foo:\n...     _bar_internal = 1\n...     @class_property\n...     def bar(cls):\n...         return cls._bar_internal + 1\n...\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(f\"Class attribute: `{Foo.bar}`\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; foo_instance = Foo()\n&gt;&gt;&gt; print(f\"Instantiated class: `{foo_instance.bar}`\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; foo_instance._bar_internal = 2\n&gt;&gt;&gt; print(\n...     f\"Modified instance attribute: `{foo_instance.bar}`\"\n... )  # Ignores instance attributes\n</code></pre> Terminal<pre><code>Class attribute: `2`\nInstantiated class: `2`\nModified instance attribute: `2`\n</code></pre> Note that in the third <code>print()</code> statement, the instance attribute <code>_bar_internal</code> is ignored. This is because <code>class_property</code> is designed to be used as a class-level property, not an instance-level property. See the Notes section for more details. <p>Conclusion: Successful usage.</p> <p>As previously noted, a <code>class_property</code> is limited to implementing read-only attributes:</p> <p>Example 2: Read-only attributes<pre><code>&gt;&gt;&gt; class Foo:\n...     _bar_internal = 1\n...     @class_property\n...     def bar(cls):\n...         return cls._bar_internal\n...     @bar.setter\n...     def bar(cls, value):\n...         cls._bar_internal = value\n...\n</code></pre> Terminal<pre><code>NotImplementedError: class_property can only be read-only; use a metaclass to implement modifiable class-level properties\n</code></pre> <p>Conclusion: Failed to set a class property.</p> Notes <ul> <li><code>@class_property</code> only works for read-only properties. It does not currently allow writeable/deletable properties, due to subtleties of how Python descriptors work. In order to implement such properties on a class, a metaclass for that class must be implemented.</li> <li><code>@class_property</code> is not a drop-in replacement for <code>property</code>. It is designed to be used as a class-level property, not an instance-level property. If you need to use it as an instance-level property, you will need to use the <code>@property</code> decorator instead.</li> <li><code>@class_property</code> is defined at class scope, not instance scope. This means that it is not bound to the instance of the class, but rather to the class itself; hence the name <code>class_property</code>. This means that it is designed to be used as a class-level property and is accessed through the class itself, not an instance-level property which is accessed through the instance of a class. If it is necessary to access the instance-level property, you will need to use the instance itself (eg. <code>instantiated_class_name._internal_attribute</code>) or create an instance-level property using the <code>@property</code> decorator.</li> </ul> Credit <p>This <code>@class_property</code> object is heavily inspired by the <code>astropy</code> library. All credit goes to them. See: details.</p> Source code in <code>src/toolbox_python/classes.py</code> <pre><code>class class_property(property):\n    \"\"\"\n    !!! note \"Summary\"\n        Similar to `property`, but allows class-level properties. That is, a property whose getter is like a `classmethod`.\n\n    ???+ abstract \"Details\"\n        The wrapped method may explicitly use the `classmethod` decorator (which must become before this decorator), or the `classmethod` may be omitted (it is implicit through use of this decorator).\n\n    Params:\n        fget (callable):\n            The function that computes the value of this property (in particular, the function when this is used as a decorator) a la `property`.\n\n        doc (str, optional):\n            The docstring for the property--by default inherited from the getter function.\n\n    ???+ example \"Examples\"\n\n        Normal usage is as a decorator:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Normal usage\"}\n        &gt;&gt;&gt; class Foo:\n        ...     _bar_internal = 1\n        ...     @class_property\n        ...     def bar(cls):\n        ...         return cls._bar_internal + 1\n        ...\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; print(f\"Class attribute: `{Foo.bar}`\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; foo_instance = Foo()\n        &gt;&gt;&gt; print(f\"Instantiated class: `{foo_instance.bar}`\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; foo_instance._bar_internal = 2\n        &gt;&gt;&gt; print(\n        ...     f\"Modified instance attribute: `{foo_instance.bar}`\"\n        ... )  # Ignores instance attributes\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        Class attribute: `2`\n        Instantiated class: `2`\n        Modified instance attribute: `2`\n        ```\n        Note that in the third `print()` statement, the instance attribute `_bar_internal` is ignored. This is because `class_property` is designed to be used as a class-level property, not an instance-level property. See the Notes section for more details.\n        !!! success \"Conclusion: Successful usage.\"\n        &lt;/div&gt;\n\n        As previously noted, a `class_property` is limited to implementing read-only attributes:\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Read-only attributes\"}\n        &gt;&gt;&gt; class Foo:\n        ...     _bar_internal = 1\n        ...     @class_property\n        ...     def bar(cls):\n        ...         return cls._bar_internal\n        ...     @bar.setter\n        ...     def bar(cls, value):\n        ...         cls._bar_internal = value\n        ...\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        NotImplementedError: class_property can only be read-only; use a metaclass to implement modifiable class-level properties\n        ```\n        !!! failure \"Conclusion: Failed to set a class property.\"\n        &lt;/div&gt;\n\n    ???+ info \"Notes\"\n        - `@class_property` only works for *read-only* properties. It does not currently allow writeable/deletable properties, due to subtleties of how Python descriptors work. In order to implement such properties on a class, a metaclass for that class must be implemented.\n        - `@class_property` is not a drop-in replacement for `property`. It is designed to be used as a class-level property, not an instance-level property. If you need to use it as an instance-level property, you will need to use the `@property` decorator instead.\n        - `@class_property` is defined at class scope, not instance scope. This means that it is not bound to the instance of the class, but rather to the class itself; hence the name `class_property`. This means that it is designed to be used as a class-level property and is accessed through the class itself, not an instance-level property which is accessed through the instance of a class. If it is necessary to access the instance-level property, you will need to use the instance itself (eg. `instantiated_class_name._internal_attribute`) or create an instance-level property using the `@property` decorator.\n\n    ???+ success \"Credit\"\n        This `@class_property` object is heavily inspired by the [`astropy`](https://www.astropy.org/) library. All credit goes to them. See: [details](https://github.com/astropy/astropy/blob/e4993fffb54e19b04bc4e9af084984650bc0a46f/astropy/utils/decorators.py#L551-L722).\n    \"\"\"\n\n    def __new__(cls, fget=None, doc=None):\n\n        if fget is None:\n\n            # Being used as a decorator-return a wrapper that implements decorator syntax\n            def wrapper(func):\n                return cls(func, doc=doc)\n\n            return wrapper\n\n        return super().__new__(cls)\n\n    def __init__(self, fget, doc=None):\n\n        fget = self._wrap_fget(fget)\n        super().__init__(fget=fget, doc=doc)\n\n        # There is a bug in Python where `self.__doc__` doesn't get set properly on instances of property subclasses if the `doc` argument was used rather than taking the docstring from `fget`.\n        # Related Python issue: https://bugs.python.org/issue24766\n        if doc is not None:\n            self.__doc__ = doc\n\n    def __get__(self, obj, objtype) -&gt; Any:  # type: ignore[override]\n        # The base `property.__get__` will just return self here; instead we pass `objtype` through to the original wrapped function (which takes the `class` as its sole argument). This is how we obtain the `class` attribute and not the `instance` attribute, and the key difference between `@property` and `@class_property`. This is also the same as `classmethod.__get__()`, but we need to pass `objtype` rather than `obj` to the wrapped function.\n        val: Any = self.fget.__wrapped__(objtype)  # type: ignore[union-attr]\n        return val\n\n    @staticmethod\n    def _wrap_fget(orig_fget):\n        if isinstance(orig_fget, classmethod):\n            orig_fget = orig_fget.__func__\n\n        # Using standard `functools.wraps` for simplicity.\n        @wraps(orig_fget)  # pragma: no cover\n        def fget(obj):\n            return orig_fget(obj.__class__)\n\n        return fget\n\n    # def getter(self, fget) -&gt; property:\n    #     return super().getter(self._wrap_fget(fget))\n\n    def setter(self, fset) -&gt; Any:\n        raise NotImplementedError(\n            \"class_property can only be read-only; use a metaclass to implement modifiable class-level properties\"\n        )\n\n    def deleter(self, fdel) -&gt; Any:\n        raise NotImplementedError(\n            \"class_property can only be read-only; use a metaclass to implement modifiable class-level properties\"\n        )\n</code></pre>"},{"location":"code/classes/#toolbox_python.classes.class_property.__new__","title":"__new__","text":"<pre><code>__new__(fget=None, doc=None)\n</code></pre> Source code in <code>src/toolbox_python/classes.py</code> <pre><code>def __new__(cls, fget=None, doc=None):\n\n    if fget is None:\n\n        # Being used as a decorator-return a wrapper that implements decorator syntax\n        def wrapper(func):\n            return cls(func, doc=doc)\n\n        return wrapper\n\n    return super().__new__(cls)\n</code></pre>"},{"location":"code/classes/#toolbox_python.classes.class_property.__init__","title":"__init__","text":"<pre><code>__init__(fget, doc=None)\n</code></pre> Source code in <code>src/toolbox_python/classes.py</code> <pre><code>def __init__(self, fget, doc=None):\n\n    fget = self._wrap_fget(fget)\n    super().__init__(fget=fget, doc=doc)\n\n    # There is a bug in Python where `self.__doc__` doesn't get set properly on instances of property subclasses if the `doc` argument was used rather than taking the docstring from `fget`.\n    # Related Python issue: https://bugs.python.org/issue24766\n    if doc is not None:\n        self.__doc__ = doc\n</code></pre>"},{"location":"code/classes/#toolbox_python.classes.class_property.__doc__","title":"__doc__  <code>instance-attribute</code>","text":"<pre><code>__doc__ = doc\n</code></pre>"},{"location":"code/classes/#toolbox_python.classes.class_property.__get__","title":"__get__","text":"<pre><code>__get__(obj, objtype) -&gt; Any\n</code></pre> Source code in <code>src/toolbox_python/classes.py</code> <pre><code>def __get__(self, obj, objtype) -&gt; Any:  # type: ignore[override]\n    # The base `property.__get__` will just return self here; instead we pass `objtype` through to the original wrapped function (which takes the `class` as its sole argument). This is how we obtain the `class` attribute and not the `instance` attribute, and the key difference between `@property` and `@class_property`. This is also the same as `classmethod.__get__()`, but we need to pass `objtype` rather than `obj` to the wrapped function.\n    val: Any = self.fget.__wrapped__(objtype)  # type: ignore[union-attr]\n    return val\n</code></pre>"},{"location":"code/classes/#toolbox_python.classes.class_property.setter","title":"setter","text":"<pre><code>setter(fset) -&gt; Any\n</code></pre> Source code in <code>src/toolbox_python/classes.py</code> <pre><code>def setter(self, fset) -&gt; Any:\n    raise NotImplementedError(\n        \"class_property can only be read-only; use a metaclass to implement modifiable class-level properties\"\n    )\n</code></pre>"},{"location":"code/classes/#toolbox_python.classes.class_property.deleter","title":"deleter","text":"<pre><code>deleter(fdel) -&gt; Any\n</code></pre> Source code in <code>src/toolbox_python/classes.py</code> <pre><code>def deleter(self, fdel) -&gt; Any:\n    raise NotImplementedError(\n        \"class_property can only be read-only; use a metaclass to implement modifiable class-level properties\"\n    )\n</code></pre>"},{"location":"code/defaults/","title":"Defaults","text":""},{"location":"code/defaults/#toolbox_python.defaults","title":"toolbox_python.defaults","text":"<p>Summary</p> <p>The <code>defaults</code> module is used how to set and control default values for our various Python processes.</p>"},{"location":"code/defaults/#toolbox_python.defaults.Defaults","title":"toolbox_python.defaults.Defaults","text":"<p>Summary</p> <p>When we create and use Python variables, it is sometimes handy to add a default value for that variable. This class will handle that process.</p> Examples Set up data for examples<pre><code>&gt;&gt;&gt; from toolbox_python.defaults import Defaults\n&gt;&gt;&gt; defaults = Defaults()\n</code></pre> <p>Example 1: Call direct from class<pre><code>&gt;&gt;&gt; print(Defaults()(value=\"this\"))\n</code></pre> Terminal<pre><code>\"this\"\n</code></pre> <p>Conclusion: Successfully printed default value direct from class.</p> <p>Example 2: Call from instantiated class<pre><code>&gt;&gt;&gt; print(defaults(value=\"that\"))\n</code></pre> Terminal<pre><code>\"that\"\n</code></pre> <p>Conclusion: Successfully printed default value from instantiated class.</p> <p>Example 3: Cast to `bool`<pre><code>&gt;&gt;&gt; print(defaults(value=\"True\", cast=bool))\n</code></pre> Terminal<pre><code>True\n</code></pre> <p>Conclusion: Successfully casted to <code>bool</code>.</p> <p>Example 4: Cast to `int`<pre><code>&gt;&gt;&gt; print(defaults(value=\"1\", cast=int))\n</code></pre> Terminal<pre><code>1\n</code></pre> <p>Conclusion: Successfully casted to <code>int</code>.</p> <p>Example 5: Cast to `str`<pre><code>&gt;&gt;&gt; print(defaults(value=1, cast=str))\n</code></pre> Terminal<pre><code>\"1\"\n</code></pre> <p>Conclusion: Successfully casted to <code>str</code>.</p> <p>Example 6: Cast to string `'str'`<pre><code>&gt;&gt;&gt; print(defaults(value=1, cast=\"str\"))\n</code></pre> Terminal<pre><code>\"1\"\n</code></pre> <p>Conclusion: Successfully casted to <code>str</code>.</p> <p>Note: The only difference between this and the previous example is the type of the <code>cast</code> parameter. Here, it is a string representation of the type, whereas in the previous example, we parse'ed in the actual <code>str</code> class.</p> <p>Example 7: Invalid cast type<pre><code>&gt;&gt;&gt; print(defaults(value=\"next\", cast=\"bad_type\"))\n</code></pre> Terminal<pre><code>AttributeError: The value for `type` is invalid: `bad_type`.\nMust be a valid type: ['bool', 'dict', 'int', 'float', 'list', 'str', 'tuple']\n</code></pre> <p>Conclusion: Invalid cast type.</p> <p>Example 8: All blank values<pre><code>&gt;&gt;&gt; print(defaults(value=None, cast=None))\n</code></pre> Terminal<pre><code>AttributeError: Both `value` and `default` are blank: 'None', 'None'.\nIf `value` is blank, then `default` cannot be blank.\n</code></pre> <p>Conclusion: Both <code>value</code> and <code>default</code> are blank.</p> Credit <p>Inspiration from: https://github.com/henriquebastos/python-decouple/</p> Source code in <code>src/toolbox_python/defaults.py</code> <pre><code>class Defaults:\n    \"\"\"\n    !!! note \"Summary\"\n        When we create and use Python variables, it is sometimes handy to add a default value for that variable.\n        This class will handle that process.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up data for examples\"}\n        &gt;&gt;&gt; from toolbox_python.defaults import Defaults\n        &gt;&gt;&gt; defaults = Defaults()\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Call direct from class\"}\n        &gt;&gt;&gt; print(Defaults()(value=\"this\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        \"this\"\n        ```\n        !!! success \"Conclusion: Successfully printed default value direct from class.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Call from instantiated class\"}\n        &gt;&gt;&gt; print(defaults(value=\"that\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        \"that\"\n        ```\n        !!! success \"Conclusion: Successfully printed default value from instantiated class.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Cast to `bool`\"}\n        &gt;&gt;&gt; print(defaults(value=\"True\", cast=bool))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        True\n        ```\n        !!! success \"Conclusion: Successfully casted to `#!py bool`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Cast to `int`\"}\n        &gt;&gt;&gt; print(defaults(value=\"1\", cast=int))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        1\n        ```\n        !!! success \"Conclusion: Successfully casted to `#!py int`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 5: Cast to `str`\"}\n        &gt;&gt;&gt; print(defaults(value=1, cast=str))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        \"1\"\n        ```\n        !!! success \"Conclusion: Successfully casted to `#!py str`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 6: Cast to string `'str'`\"}\n        &gt;&gt;&gt; print(defaults(value=1, cast=\"str\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        \"1\"\n        ```\n        !!! success \"Conclusion: Successfully casted to `#!py str`.\"\n        !!! observation \"Note: The only difference between this and the previous example is the type of the `cast` parameter. Here, it is a string representation of the type, whereas in the previous example, we parse'ed in the actual `str` class.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 7: Invalid cast type\"}\n        &gt;&gt;&gt; print(defaults(value=\"next\", cast=\"bad_type\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        AttributeError: The value for `type` is invalid: `bad_type`.\n        Must be a valid type: ['bool', 'dict', 'int', 'float', 'list', 'str', 'tuple']\n        ```\n        !!! failure \"Conclusion: Invalid cast type.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 8: All blank values\"}\n        &gt;&gt;&gt; print(defaults(value=None, cast=None))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        AttributeError: Both `value` and `default` are blank: 'None', 'None'.\n        If `value` is blank, then `default` cannot be blank.\n        ```\n        !!! failure \"Conclusion: Both `value` and `default` are blank.\"\n        &lt;/div&gt;\n\n    ??? success \"Credit\"\n        Inspiration from:&lt;br&gt;\n        https://github.com/henriquebastos/python-decouple/\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Nothing is initialised when this class is instantiated.\n            Use the [`__call__()`][toolbox_python.defaults.Defaults.__call__] method instead.\n\n        ??? tip \"See Also\"\n            - [`Defaults.__call__()`][toolbox_python.defaults.Defaults.__call__]\n        \"\"\"\n        return None\n\n    def __call__(self, *args, **kwargs) -&gt; Any:\n        \"\"\"\n        !!! note \"Summary\"\n            When this class is called, it will pass through all parameters to the internal [`.get()`][toolbox_python.defaults.Defaults.get] method.\n\n        ??? tip \"See Also\"\n            - [`Defaults.get()`][toolbox_python.defaults.Defaults.get]\n        \"\"\"\n        return self.get(*args, **kwargs)\n\n    @typechecked\n    def get(\n        self,\n        value: Any,\n        default: Any | None = None,\n        cast: str | type | None = None,\n    ) -&gt; Any:\n        \"\"\"\n        !!! note \"Summary\"\n            From the value that is parsed in to the `value` parameter, convert it to `default` if `value` is `#!py None`, and convert it to `cast` if `cast` is not `#!py None`.\n\n        ???+ info \"Details\"\n            The detailed steps will be:\n\n            1. Validate the input (using the internal [`._validate_value_and_default()`][toolbox_python.defaults.Defaults._validate_value_and_default] &amp; [`._validate_type()`][toolbox_python.defaults.Defaults._validate_type] methods),\n            1. If `value` is `#!py None`, then assign `default` to `value`.\n            1. If `cast` is _not_ `#!py None`, then cast `value` to the data type in `cast`.\n                - Note, `cast` can be _either_ the actual type to convert to, _or_ a string representation of the type.\n            1. Return the updated/defaulted/casted `value` back to the user.\n\n        Params:\n            value (Any):\n                The value to check.\n            default (Optional[Any], optional):\n                The default value for `value`.&lt;br&gt;\n                Note, can be a `#!py None` value; however, if `value` is also `#!py None`, then `default` _cannot_ be `#!py None`.&lt;br&gt;\n                Defaults to `#!py None`.\n            cast (Optional[Union[str, type]], optional):\n                The data type to convert to.&lt;br&gt;\n                Must be one of: `#!py [\"bool\", \"dict\", \"int\", \"float\", \"list\", \"str\", \"tuple\"]`.&lt;br&gt;\n                Defaults to `#!py None`.\n\n        Raises:\n            TypeCheckError:\n                If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n        Returns:\n            value (Any):\n                The updated/defaulted/casted value.\n\n        ???+ example \"Examples\"\n            ```pycon {.py .python linenums=\"1\" title=\"Prepare data for examples\"}\n            &gt;&gt;&gt; from toolbox_python.defaults import Defaults\n            &gt;&gt;&gt; defaults = Defaults()\n            ```\n\n            ```pycon {.py .python linenums=\"1\" title=\"Example 1: Call direct from class\"}\n            &gt;&gt;&gt; print(Defaults()(value=\"this\"))\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.txt .text title=\"Terminal\"}\n            \"this\"\n            ```\n            !!! success \"Conclusion: Successfully printed default value direct from class.\"\n            &lt;/div&gt;\n\n            ```pycon {.py .python linenums=\"1\" title=\"Example 2: Call from instantiated class\"}\n            &gt;&gt;&gt; print(defaults(value=\"that\"))\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.txt .text title=\"Terminal\"}\n            \"that\"\n            ```\n            !!! success \"Conclusion: Successfully printed default value from instantiated class.\"\n            &lt;/div&gt;\n\n            ```pycon {.py .python linenums=\"1\" title=\"Example 3: Cast to `bool`\"}\n            &gt;&gt;&gt; print(defaults(value=\"True\", cast=bool))\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.txt .text title=\"Terminal\"}\n            True\n            ```\n            !!! success \"Conclusion: Successfully casted to `#!py bool`.\"\n            &lt;/div&gt;\n\n            ```pycon {.py .python linenums=\"1\" title=\"Example 4: Cast to `int`\"}\n            &gt;&gt;&gt; print(defaults(value=\"1\", cast=int))\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.txt .text title=\"Terminal\"}\n            1\n            ```\n            !!! success \"Conclusion: Successfully casted to `#!py int`.\"\n            &lt;/div&gt;\n\n            ```pycon {.py .python linenums=\"1\" title=\"Example 5: Cast to `str`\"}\n            &gt;&gt;&gt; print(defaults(value=1, cast=str))\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.txt .text title=\"Terminal\"}\n            \"1\"\n            ```\n            !!! success \"Conclusion: Successfully casted to `#!py str`.\"\n            &lt;/div&gt;\n\n            ```pycon {.py .python linenums=\"1\" title=\"Example 6: Cast to string `'str'`\"}\n            &gt;&gt;&gt; print(defaults(value=1, cast=\"str\"))\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.txt .text title=\"Terminal\"}\n            \"1\"\n            ```\n            !!! success \"Conclusion: Successfully casted to `#!py str`.\"\n            !!! observation \"Note: The only difference between this and the previous example is the type of the `cast` parameter. Here, it is a string representation of the type, whereas in the previous example, we parse'ed in the actual `str` class.\"\n            &lt;/div&gt;\n\n            ```pycon {.py .python linenums=\"1\" title=\"Example 7: Invalid cast type\"}\n            &gt;&gt;&gt; print(defaults(value=\"next\", cast=\"bad_type\"))\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.txt .text title=\"Terminal\"}\n            AttributeError: The value for `type` is invalid: `bad_type`.\n            Must be a valid type: ['bool', 'dict', 'int', 'float', 'list', 'str', 'tuple']\n            ```\n            !!! failure \"Conclusion: Invalid cast type.\"\n            &lt;/div&gt;\n\n            ```pycon {.py .python linenums=\"1\" title=\"Example 8: All blank values\"}\n            &gt;&gt;&gt; print(defaults(value=None, cast=None))\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.txt .text title=\"Terminal\"}\n            AttributeError: Both `value` and `default` are blank: 'None', 'None'.\n            If `value` is blank, then `default` cannot be blank.\n            ```\n            !!! failure \"Conclusion: Both `value` and `default` are blank.\"\n            &lt;/div&gt;\n\n        ??? tip \"See Also\"\n            - [`Defaults._validate_value_and_default()`][toolbox_python.defaults.Defaults._validate_value_and_default]\n            - [`Defaults._validate_type()`][toolbox_python.defaults.Defaults._validate_type]\n        \"\"\"\n        (\n            self._validate_value_and_default(\n                value=value, default=default\n            )._validate_type(check_type=cast)\n        )\n        if value is None:\n            value = default\n        if cast is not None:\n            if (cast is bool or cast == \"bool\") and is_type(value, str):\n                value = bool(strtobool(value))\n            elif isinstance(cast, str):\n                value = eval(cast)(value)\n            else:\n                value = cast(value)\n        return value\n\n    def _validate_value_and_default(\n        self,\n        value: Any | None = None,\n        default: Any | None = None,\n    ) -&gt; Defaults:\n        \"\"\"\n        !!! note \"Summary\"\n            Validate to ensure that `value` and `default` are not both `#!py None`.\n\n        Params:\n            value (Optional[Any], optional):\n                The `value` to check.&lt;br&gt;\n                Defaults to `#!py None`.\n            default (Optional[Any], optional):\n                The `default` value to check.&lt;br&gt;\n                Defaults to `#!py None`.\n\n        Raises:\n            AttributeError: If both `value` and `default` are `#!py None`.\n\n        Returns:\n            self (Defaults):\n                If both `value` and `default` are not both `#!py None`, then return `self`.\n\n        ??? tip \"See Also\"\n            - [`Defaults.get()`][toolbox_python.defaults.Defaults.get]\n        \"\"\"\n        if value is None and default is None:\n            raise AttributeError(\n                f\"Both `value` and `default` are blank: '{value}', '{default}'.\\n\"\n                f\"If `value` is blank, then `default` cannot be blank.\"\n            )\n        return self\n\n    def _validate_type(\n        self,\n        check_type: str | type | None = None,\n    ) -&gt; Defaults:\n        \"\"\"\n        !!! note \"Summary\"\n            Check to ensure that `check_type` is a valid Python type.&lt;br&gt;\n            Must be one of: `#!py [\"bool\", \"dict\", \"int\", \"float\", \"list\", \"str\", \"tuple\"]`.\n\n        Params:\n            check_type (Optional[Union[str, type]], optional):\n                The type to check against. Can either be an actual Python type, or it's string representation.&lt;br&gt;\n                Defaults to `#!py None`.\n\n        Raises:\n            AttributeError: If `check_type` is _both_ not `#!py None` _and_ if it is not one of the valid Python types.\n\n        Returns:\n            self (Defaults):\n                If the type is valid, return `self`.\n\n        ??? tip \"See Also\"\n            - [`Defaults.get()`][toolbox_python.defaults.Defaults.get]\n        \"\"\"\n        valid_types: str_list = [\n            \"bool\",\n            \"dict\",\n            \"int\",\n            \"float\",\n            \"list\",\n            \"str\",\n            \"tuple\",\n        ]\n        retype: str | type | None = None\n        if check_type is None:\n            return self\n        elif is_type(check_type, str):\n            retype = check_type\n        elif type(check_type).__name__ == \"type\":\n            retype = check_type.__name__  # type: ignore\n        if retype is not None and retype not in valid_types:\n            raise AttributeError(\n                f\"The value for `type` is invalid: `{retype}`.\\n\"\n                f\"Must be a valid type: {valid_types}.\"\n            )\n        return self\n</code></pre>"},{"location":"code/defaults/#toolbox_python.defaults.Defaults.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Summary</p> <p>Nothing is initialised when this class is instantiated. Use the <code>__call__()</code> method instead.</p> See Also <ul> <li><code>Defaults.__call__()</code></li> </ul> Source code in <code>src/toolbox_python/defaults.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Nothing is initialised when this class is instantiated.\n        Use the [`__call__()`][toolbox_python.defaults.Defaults.__call__] method instead.\n\n    ??? tip \"See Also\"\n        - [`Defaults.__call__()`][toolbox_python.defaults.Defaults.__call__]\n    \"\"\"\n    return None\n</code></pre>"},{"location":"code/defaults/#toolbox_python.defaults.Defaults.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs) -&gt; Any\n</code></pre> <p>Summary</p> <p>When this class is called, it will pass through all parameters to the internal <code>.get()</code> method.</p> See Also <ul> <li><code>Defaults.get()</code></li> </ul> Source code in <code>src/toolbox_python/defaults.py</code> <pre><code>def __call__(self, *args, **kwargs) -&gt; Any:\n    \"\"\"\n    !!! note \"Summary\"\n        When this class is called, it will pass through all parameters to the internal [`.get()`][toolbox_python.defaults.Defaults.get] method.\n\n    ??? tip \"See Also\"\n        - [`Defaults.get()`][toolbox_python.defaults.Defaults.get]\n    \"\"\"\n    return self.get(*args, **kwargs)\n</code></pre>"},{"location":"code/defaults/#toolbox_python.defaults.Defaults.get","title":"get","text":"<pre><code>get(\n    value: Any,\n    default: Any | None = None,\n    cast: str | type | None = None,\n) -&gt; Any\n</code></pre> <p>Summary</p> <p>From the value that is parsed in to the <code>value</code> parameter, convert it to <code>default</code> if <code>value</code> is <code>None</code>, and convert it to <code>cast</code> if <code>cast</code> is not <code>None</code>.</p> Details <p>The detailed steps will be:</p> <ol> <li>Validate the input (using the internal <code>._validate_value_and_default()</code> &amp; <code>._validate_type()</code> methods),</li> <li>If <code>value</code> is <code>None</code>, then assign <code>default</code> to <code>value</code>.</li> <li>If <code>cast</code> is not <code>None</code>, then cast <code>value</code> to the data type in <code>cast</code>.<ul> <li>Note, <code>cast</code> can be either the actual type to convert to, or a string representation of the type.</li> </ul> </li> <li>Return the updated/defaulted/casted <code>value</code> back to the user.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <code>default</code> <code>Optional[Any]</code> <p>The default value for <code>value</code>. Note, can be a <code>None</code> value; however, if <code>value</code> is also <code>None</code>, then <code>default</code> cannot be <code>None</code>. Defaults to <code>None</code>.</p> <code>None</code> <code>cast</code> <code>Optional[Union[str, type]]</code> <p>The data type to convert to. Must be one of: <code>[\"bool\", \"dict\", \"int\", \"float\", \"list\", \"str\", \"tuple\"]</code>. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Name Type Description <code>value</code> <code>Any</code> <p>The updated/defaulted/casted value.</p> Examples Prepare data for examples<pre><code>&gt;&gt;&gt; from toolbox_python.defaults import Defaults\n&gt;&gt;&gt; defaults = Defaults()\n</code></pre> <p>Example 1: Call direct from class<pre><code>&gt;&gt;&gt; print(Defaults()(value=\"this\"))\n</code></pre> Terminal<pre><code>\"this\"\n</code></pre> <p>Conclusion: Successfully printed default value direct from class.</p> <p>Example 2: Call from instantiated class<pre><code>&gt;&gt;&gt; print(defaults(value=\"that\"))\n</code></pre> Terminal<pre><code>\"that\"\n</code></pre> <p>Conclusion: Successfully printed default value from instantiated class.</p> <p>Example 3: Cast to `bool`<pre><code>&gt;&gt;&gt; print(defaults(value=\"True\", cast=bool))\n</code></pre> Terminal<pre><code>True\n</code></pre> <p>Conclusion: Successfully casted to <code>bool</code>.</p> <p>Example 4: Cast to `int`<pre><code>&gt;&gt;&gt; print(defaults(value=\"1\", cast=int))\n</code></pre> Terminal<pre><code>1\n</code></pre> <p>Conclusion: Successfully casted to <code>int</code>.</p> <p>Example 5: Cast to `str`<pre><code>&gt;&gt;&gt; print(defaults(value=1, cast=str))\n</code></pre> Terminal<pre><code>\"1\"\n</code></pre> <p>Conclusion: Successfully casted to <code>str</code>.</p> <p>Example 6: Cast to string `'str'`<pre><code>&gt;&gt;&gt; print(defaults(value=1, cast=\"str\"))\n</code></pre> Terminal<pre><code>\"1\"\n</code></pre> <p>Conclusion: Successfully casted to <code>str</code>.</p> <p>Note: The only difference between this and the previous example is the type of the <code>cast</code> parameter. Here, it is a string representation of the type, whereas in the previous example, we parse'ed in the actual <code>str</code> class.</p> <p>Example 7: Invalid cast type<pre><code>&gt;&gt;&gt; print(defaults(value=\"next\", cast=\"bad_type\"))\n</code></pre> Terminal<pre><code>AttributeError: The value for `type` is invalid: `bad_type`.\nMust be a valid type: ['bool', 'dict', 'int', 'float', 'list', 'str', 'tuple']\n</code></pre> <p>Conclusion: Invalid cast type.</p> <p>Example 8: All blank values<pre><code>&gt;&gt;&gt; print(defaults(value=None, cast=None))\n</code></pre> Terminal<pre><code>AttributeError: Both `value` and `default` are blank: 'None', 'None'.\nIf `value` is blank, then `default` cannot be blank.\n</code></pre> <p>Conclusion: Both <code>value</code> and <code>default</code> are blank.</p> See Also <ul> <li><code>Defaults._validate_value_and_default()</code></li> <li><code>Defaults._validate_type()</code></li> </ul> Source code in <code>src/toolbox_python/defaults.py</code> <pre><code>@typechecked\ndef get(\n    self,\n    value: Any,\n    default: Any | None = None,\n    cast: str | type | None = None,\n) -&gt; Any:\n    \"\"\"\n    !!! note \"Summary\"\n        From the value that is parsed in to the `value` parameter, convert it to `default` if `value` is `#!py None`, and convert it to `cast` if `cast` is not `#!py None`.\n\n    ???+ info \"Details\"\n        The detailed steps will be:\n\n        1. Validate the input (using the internal [`._validate_value_and_default()`][toolbox_python.defaults.Defaults._validate_value_and_default] &amp; [`._validate_type()`][toolbox_python.defaults.Defaults._validate_type] methods),\n        1. If `value` is `#!py None`, then assign `default` to `value`.\n        1. If `cast` is _not_ `#!py None`, then cast `value` to the data type in `cast`.\n            - Note, `cast` can be _either_ the actual type to convert to, _or_ a string representation of the type.\n        1. Return the updated/defaulted/casted `value` back to the user.\n\n    Params:\n        value (Any):\n            The value to check.\n        default (Optional[Any], optional):\n            The default value for `value`.&lt;br&gt;\n            Note, can be a `#!py None` value; however, if `value` is also `#!py None`, then `default` _cannot_ be `#!py None`.&lt;br&gt;\n            Defaults to `#!py None`.\n        cast (Optional[Union[str, type]], optional):\n            The data type to convert to.&lt;br&gt;\n            Must be one of: `#!py [\"bool\", \"dict\", \"int\", \"float\", \"list\", \"str\", \"tuple\"]`.&lt;br&gt;\n            Defaults to `#!py None`.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        value (Any):\n            The updated/defaulted/casted value.\n\n    ???+ example \"Examples\"\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data for examples\"}\n        &gt;&gt;&gt; from toolbox_python.defaults import Defaults\n        &gt;&gt;&gt; defaults = Defaults()\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Call direct from class\"}\n        &gt;&gt;&gt; print(Defaults()(value=\"this\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        \"this\"\n        ```\n        !!! success \"Conclusion: Successfully printed default value direct from class.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Call from instantiated class\"}\n        &gt;&gt;&gt; print(defaults(value=\"that\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        \"that\"\n        ```\n        !!! success \"Conclusion: Successfully printed default value from instantiated class.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Cast to `bool`\"}\n        &gt;&gt;&gt; print(defaults(value=\"True\", cast=bool))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        True\n        ```\n        !!! success \"Conclusion: Successfully casted to `#!py bool`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Cast to `int`\"}\n        &gt;&gt;&gt; print(defaults(value=\"1\", cast=int))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        1\n        ```\n        !!! success \"Conclusion: Successfully casted to `#!py int`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 5: Cast to `str`\"}\n        &gt;&gt;&gt; print(defaults(value=1, cast=str))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        \"1\"\n        ```\n        !!! success \"Conclusion: Successfully casted to `#!py str`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 6: Cast to string `'str'`\"}\n        &gt;&gt;&gt; print(defaults(value=1, cast=\"str\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        \"1\"\n        ```\n        !!! success \"Conclusion: Successfully casted to `#!py str`.\"\n        !!! observation \"Note: The only difference between this and the previous example is the type of the `cast` parameter. Here, it is a string representation of the type, whereas in the previous example, we parse'ed in the actual `str` class.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 7: Invalid cast type\"}\n        &gt;&gt;&gt; print(defaults(value=\"next\", cast=\"bad_type\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        AttributeError: The value for `type` is invalid: `bad_type`.\n        Must be a valid type: ['bool', 'dict', 'int', 'float', 'list', 'str', 'tuple']\n        ```\n        !!! failure \"Conclusion: Invalid cast type.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 8: All blank values\"}\n        &gt;&gt;&gt; print(defaults(value=None, cast=None))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        AttributeError: Both `value` and `default` are blank: 'None', 'None'.\n        If `value` is blank, then `default` cannot be blank.\n        ```\n        !!! failure \"Conclusion: Both `value` and `default` are blank.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`Defaults._validate_value_and_default()`][toolbox_python.defaults.Defaults._validate_value_and_default]\n        - [`Defaults._validate_type()`][toolbox_python.defaults.Defaults._validate_type]\n    \"\"\"\n    (\n        self._validate_value_and_default(\n            value=value, default=default\n        )._validate_type(check_type=cast)\n    )\n    if value is None:\n        value = default\n    if cast is not None:\n        if (cast is bool or cast == \"bool\") and is_type(value, str):\n            value = bool(strtobool(value))\n        elif isinstance(cast, str):\n            value = eval(cast)(value)\n        else:\n            value = cast(value)\n    return value\n</code></pre>"},{"location":"code/defaults/#toolbox_python.defaults.Defaults._validate_value_and_default","title":"_validate_value_and_default","text":"<pre><code>_validate_value_and_default(\n    value: Any | None = None, default: Any | None = None\n) -&gt; Defaults\n</code></pre> <p>Summary</p> <p>Validate to ensure that <code>value</code> and <code>default</code> are not both <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[Any]</code> <p>The <code>value</code> to check. Defaults to <code>None</code>.</p> <code>None</code> <code>default</code> <code>Optional[Any]</code> <p>The <code>default</code> value to check. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If both <code>value</code> and <code>default</code> are <code>None</code>.</p> <p>Returns:</p> Name Type Description <code>self</code> <code>Defaults</code> <p>If both <code>value</code> and <code>default</code> are not both <code>None</code>, then return <code>self</code>.</p> See Also <ul> <li><code>Defaults.get()</code></li> </ul> Source code in <code>src/toolbox_python/defaults.py</code> <pre><code>def _validate_value_and_default(\n    self,\n    value: Any | None = None,\n    default: Any | None = None,\n) -&gt; Defaults:\n    \"\"\"\n    !!! note \"Summary\"\n        Validate to ensure that `value` and `default` are not both `#!py None`.\n\n    Params:\n        value (Optional[Any], optional):\n            The `value` to check.&lt;br&gt;\n            Defaults to `#!py None`.\n        default (Optional[Any], optional):\n            The `default` value to check.&lt;br&gt;\n            Defaults to `#!py None`.\n\n    Raises:\n        AttributeError: If both `value` and `default` are `#!py None`.\n\n    Returns:\n        self (Defaults):\n            If both `value` and `default` are not both `#!py None`, then return `self`.\n\n    ??? tip \"See Also\"\n        - [`Defaults.get()`][toolbox_python.defaults.Defaults.get]\n    \"\"\"\n    if value is None and default is None:\n        raise AttributeError(\n            f\"Both `value` and `default` are blank: '{value}', '{default}'.\\n\"\n            f\"If `value` is blank, then `default` cannot be blank.\"\n        )\n    return self\n</code></pre>"},{"location":"code/defaults/#toolbox_python.defaults.Defaults._validate_type","title":"_validate_type","text":"<pre><code>_validate_type(\n    check_type: str | type | None = None,\n) -&gt; Defaults\n</code></pre> <p>Summary</p> <p>Check to ensure that <code>check_type</code> is a valid Python type. Must be one of: <code>[\"bool\", \"dict\", \"int\", \"float\", \"list\", \"str\", \"tuple\"]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>check_type</code> <code>Optional[Union[str, type]]</code> <p>The type to check against. Can either be an actual Python type, or it's string representation. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>check_type</code> is both not <code>None</code> and if it is not one of the valid Python types.</p> <p>Returns:</p> Name Type Description <code>self</code> <code>Defaults</code> <p>If the type is valid, return <code>self</code>.</p> See Also <ul> <li><code>Defaults.get()</code></li> </ul> Source code in <code>src/toolbox_python/defaults.py</code> <pre><code>def _validate_type(\n    self,\n    check_type: str | type | None = None,\n) -&gt; Defaults:\n    \"\"\"\n    !!! note \"Summary\"\n        Check to ensure that `check_type` is a valid Python type.&lt;br&gt;\n        Must be one of: `#!py [\"bool\", \"dict\", \"int\", \"float\", \"list\", \"str\", \"tuple\"]`.\n\n    Params:\n        check_type (Optional[Union[str, type]], optional):\n            The type to check against. Can either be an actual Python type, or it's string representation.&lt;br&gt;\n            Defaults to `#!py None`.\n\n    Raises:\n        AttributeError: If `check_type` is _both_ not `#!py None` _and_ if it is not one of the valid Python types.\n\n    Returns:\n        self (Defaults):\n            If the type is valid, return `self`.\n\n    ??? tip \"See Also\"\n        - [`Defaults.get()`][toolbox_python.defaults.Defaults.get]\n    \"\"\"\n    valid_types: str_list = [\n        \"bool\",\n        \"dict\",\n        \"int\",\n        \"float\",\n        \"list\",\n        \"str\",\n        \"tuple\",\n    ]\n    retype: str | type | None = None\n    if check_type is None:\n        return self\n    elif is_type(check_type, str):\n        retype = check_type\n    elif type(check_type).__name__ == \"type\":\n        retype = check_type.__name__  # type: ignore\n    if retype is not None and retype not in valid_types:\n        raise AttributeError(\n            f\"The value for `type` is invalid: `{retype}`.\\n\"\n            f\"Must be a valid type: {valid_types}.\"\n        )\n    return self\n</code></pre>"},{"location":"code/defaults/#toolbox_python.defaults.defaults","title":"toolbox_python.defaults.defaults  <code>module-attribute</code>","text":"<pre><code>defaults = Defaults()\n</code></pre>"},{"location":"code/dictionaries/","title":"Dictionaries","text":""},{"location":"code/dictionaries/#toolbox_python.dictionaries","title":"toolbox_python.dictionaries","text":"<p>Summary</p> <p>The <code>dictionaries</code> module is used how to manipulate and enhance Python dictionaries.</p> <p>Details</p> <p>Note that functions in this module will only take-in and manipulate existing <code>dict</code> objects, and also output <code>dict</code> objects. It will not sub-class the base <code>dict</code> object, or create new '<code>dict</code>-like' objects. It will always maintain pure python types at it's core.</p>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.dict_reverse_keys_and_values","title":"dict_reverse_keys_and_values","text":"<pre><code>dict_reverse_keys_and_values(\n    dictionary: dict_any,\n) -&gt; dict_str_any\n</code></pre> <p>Summary</p> <p>Take the <code>key</code> and <code>values</code> of a dictionary, and reverse them.</p> Details <p>This process is simple enough if the <code>values</code> are atomic types, like <code>str</code>, <code>int</code>, or <code>float</code> types. But it is a little more tricky when the <code>values</code> are more complex types, like <code>list</code> or <code>dict</code>; here we need to use some recursion.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict_any</code> <p>The input <code>dict</code> that you'd like to have the <code>keys</code> and <code>values</code> switched.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <code>KeyError</code> <p>When there are duplicate <code>values</code> being coerced to <code>keys</code> in the new dictionary. Raised because a Python <code>dict</code> cannot have duplicate keys of the same value.</p> <p>Returns:</p> Name Type Description <code>output_dict</code> <code>dict_str_int</code> <p>The updated <code>dict</code>.</p> Examples Set up<pre><code>&gt;&gt;&gt; # Imports\n&gt;&gt;&gt; from toolbox_python.dictionaries import dict_reverse_keys_and_values\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Basic dictionary\n&gt;&gt;&gt; dict_basic = {\n...     \"a\": 1,\n...     \"b\": 2,\n...     \"c\": 3,\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Dictionary with iterables\n&gt;&gt;&gt; dict_iterables = {\n...     \"a\": [\"1\", \"2\", \"3\"],\n...     \"b\": [4, 5, 6],\n...     \"c\": (\"7\", \"8\", \"9\"),\n...     \"d\": (10, 11, 12),\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Dictionary with iterables and duplicates\n&gt;&gt;&gt; dict_iterables_with_duplicates = {\n...     \"a\": [1, 2, 3],\n...     \"b\": [4, 2, 5],\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Dictionary with sub-dictionaries\n&gt;&gt;&gt; dict_with_dicts = {\n...     \"a\": {\n...         \"aa\": 11,\n...         \"bb\": 22,\n...         \"cc\": 33,\n...     },\n...     \"b\": {\n...         \"dd\": [1, 2, 3],\n...         \"ee\": (\"4\", \"5\", \"6\"),\n...     },\n... }\n</code></pre> <p>Example 1: Reverse one-for-one<pre><code>&gt;&gt;&gt; print(dict_reverse_keys_and_values(dict_basic))\n</code></pre> Terminal<pre><code>{\n    \"1\": \"a\",\n    \"2\": \"b\",\n    \"3\": \"c\",\n}\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Notice here that the original values were type <code>int</code>, but here they have been converted to <code>str</code>. This is because <code>dict</code> keys should ideally only be <code>str</code> type.</p> <p>Example 2: Reverse dictionary containing iterables in `values`<pre><code>&gt;&gt;&gt; print(dict_reverse_keys_and_values(dict_iterables))\n</code></pre> Terminal<pre><code>{\n    \"1\": \"a\",\n    \"2\": \"a\",\n    \"3\": \"a\",\n    \"4\": \"b\",\n    \"5\": \"b\",\n    \"6\": \"b\",\n    \"7\": \"c\",\n    \"8\": \"c\",\n    \"9\": \"c\",\n    \"10\": \"d\",\n    \"11\": \"d\",\n    \"12\": \"d\",\n}\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Notice here how it has 'flattened' the iterables in the <code>values</code> in to individual keys, and assigned the original <code>key</code> to multiple keys. They keys have again been coerced to <code>str</code> type.</p> <p>Example 3: Dictionary with iterables, raise error when `key` already exists<pre><code>&gt;&gt;&gt; print(dict_reverse_keys_and_values(dict_iterables_with_duplicates))\n</code></pre> Terminal<pre><code>KeyError: Key already existing.\nCannot update `output_dict` with new elements: {2: 'b'}\nBecause the key is already existing for: {'2': 'a'}\nFull `output_dict` so far:\n{'1': 'a', '2': 'a', '3': 'a', '4': 'b'}\n</code></pre> <p>Conclusion: Failed conversion.</p> <p>Here, in the second element of the dictionary (<code>\"b\"</code>), there is a duplicate value <code>2</code> which is already existing in the first element of the dictionary (<code>\"a\"</code>). So, we would expect to see an error.Remember, a Python <code>dict</code> object cannot contain duplicate keys. They must always be unique.</p> <p>Example 4: Dictionary with embedded dictionaries<pre><code>&gt;&gt;&gt; print(dict_reverse_keys_and_values(dict_with_dicts))\n</code></pre> Terminal<pre><code>{\n    \"1\": \"a\",\n    \"2\": \"a\",\n    \"3\": \"a\",\n    \"4\": \"b\",\n    \"5\": \"b\",\n    \"6\": \"b\",\n    \"7\": \"c\",\n    \"8\": \"c\",\n    \"9\": \"c\",\n    \"10\": \"d\",\n    \"11\": \"d\",\n    \"12\": \"d\",\n}\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Here, the process would be to run a recursive process when it recognises that any <code>value</code> is a <code>dict</code> object. So long as there are no duplicate values in any of the contained <code>dict</code>'s, the resulting output will be a big, flat dictionary.</p> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>@typechecked\ndef dict_reverse_keys_and_values(dictionary: dict_any) -&gt; dict_str_any:\n    \"\"\"\n    !!! note \"Summary\"\n        Take the `key` and `values` of a dictionary, and reverse them.\n\n    ???+ info \"Details\"\n        This process is simple enough if the `values` are atomic types, like `#!py str`, `#!py int`, or `#!py float` types. But it is a little more tricky when the `values` are more complex types, like `#!py list` or `#!py dict`; here we need to use some recursion.\n\n    Params:\n        dictionary (dict_any):\n            The input `#!py dict` that you'd like to have the `keys` and `values` switched.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n        KeyError:\n            When there are duplicate `values` being coerced to `keys` in the new dictionary. Raised because a Python `#!py dict` cannot have duplicate keys of the same value.\n\n    Returns:\n        output_dict (dict_str_int):\n            The updated `#!py dict`.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; # Imports\n        &gt;&gt;&gt; from toolbox_python.dictionaries import dict_reverse_keys_and_values\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Basic dictionary\n        &gt;&gt;&gt; dict_basic = {\n        ...     \"a\": 1,\n        ...     \"b\": 2,\n        ...     \"c\": 3,\n        ... }\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Dictionary with iterables\n        &gt;&gt;&gt; dict_iterables = {\n        ...     \"a\": [\"1\", \"2\", \"3\"],\n        ...     \"b\": [4, 5, 6],\n        ...     \"c\": (\"7\", \"8\", \"9\"),\n        ...     \"d\": (10, 11, 12),\n        ... }\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Dictionary with iterables and duplicates\n        &gt;&gt;&gt; dict_iterables_with_duplicates = {\n        ...     \"a\": [1, 2, 3],\n        ...     \"b\": [4, 2, 5],\n        ... }\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Dictionary with sub-dictionaries\n        &gt;&gt;&gt; dict_with_dicts = {\n        ...     \"a\": {\n        ...         \"aa\": 11,\n        ...         \"bb\": 22,\n        ...         \"cc\": 33,\n        ...     },\n        ...     \"b\": {\n        ...         \"dd\": [1, 2, 3],\n        ...         \"ee\": (\"4\", \"5\", \"6\"),\n        ...     },\n        ... }\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Reverse one-for-one\"}\n        &gt;&gt;&gt; print(dict_reverse_keys_and_values(dict_basic))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        {\n            \"1\": \"a\",\n            \"2\": \"b\",\n            \"3\": \"c\",\n        }\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        !!! observation \"Notice here that the original values were type `#!py int`, but here they have been converted to `#!py str`. This is because `#!py dict` keys should ideally only be `#!py str` type.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Reverse dictionary containing iterables in `values`\"}\n        &gt;&gt;&gt; print(dict_reverse_keys_and_values(dict_iterables))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        {\n            \"1\": \"a\",\n            \"2\": \"a\",\n            \"3\": \"a\",\n            \"4\": \"b\",\n            \"5\": \"b\",\n            \"6\": \"b\",\n            \"7\": \"c\",\n            \"8\": \"c\",\n            \"9\": \"c\",\n            \"10\": \"d\",\n            \"11\": \"d\",\n            \"12\": \"d\",\n        }\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        !!! observation \"Notice here how it has 'flattened' the iterables in the `values` in to individual keys, and assigned the original `key` to multiple keys. They keys have again been coerced to `#!py str` type.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Dictionary with iterables, raise error when `key` already exists\"}\n        &gt;&gt;&gt; print(dict_reverse_keys_and_values(dict_iterables_with_duplicates))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        KeyError: Key already existing.\n        Cannot update `output_dict` with new elements: {2: 'b'}\n        Because the key is already existing for: {'2': 'a'}\n        Full `output_dict` so far:\n        {'1': 'a', '2': 'a', '3': 'a', '4': 'b'}\n        ```\n        !!! failure \"Conclusion: Failed conversion.\"\n        !!! observation \"Here, in the second element of the dictionary (`#!py \"b\"`), there is a duplicate value `#!py 2` which is already existing in the first element of the dictionary (`#!py \"a\"`). So, we would expect to see an error.&lt;br&gt;Remember, a Python `#!py dict` object _cannot_ contain duplicate keys. They must always be unique.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Dictionary with embedded dictionaries\"}\n        &gt;&gt;&gt; print(dict_reverse_keys_and_values(dict_with_dicts))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        {\n            \"1\": \"a\",\n            \"2\": \"a\",\n            \"3\": \"a\",\n            \"4\": \"b\",\n            \"5\": \"b\",\n            \"6\": \"b\",\n            \"7\": \"c\",\n            \"8\": \"c\",\n            \"9\": \"c\",\n            \"10\": \"d\",\n            \"11\": \"d\",\n            \"12\": \"d\",\n        }\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        !!! observation \"Here, the process would be to run a recursive process when it recognises that any `value` is a `#!py dict` object. So long as there are no duplicate values in any of the contained `#!py dict`'s, the resulting output will be a big, flat dictionary.\"\n        &lt;/div&gt;\n    \"\"\"\n    output_dict: dict_str_any = dict()\n    for key, value in dictionary.items():\n        if isinstance(value, (str, int, float)):\n            output_dict[str(value)] = key\n        elif isinstance(value, (tuple, list)):\n            for elem in value:\n                if str(elem) in output_dict.keys():\n                    raise KeyError(\n                        f\"Key already existing.\\n\"\n                        f\"Cannot update `output_dict` with new elements: { {elem: key} }\\n\"\n                        f\"Because the key is already existing for: { {new_key: new_value for (new_key, new_value) in output_dict.items() if new_key==str(elem)} }\\n\"\n                        f\"Full `output_dict` so far:\\n{output_dict}\"\n                    )\n                output_dict[str(elem)] = key\n        elif isinstance(value, dict):\n            interim_dict: dict_str_any = dict_reverse_keys_and_values(value)\n            output_dict = {\n                **output_dict,\n                **interim_dict,\n            }\n    return output_dict\n</code></pre>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.DotDict","title":"DotDict","text":"<p>               Bases: <code>dict</code></p> <p>Summary</p> <p>Dictionary subclass that allows dot notation access to keys.</p> <p>Details</p> <p>Nested dictionaries are automatically converted to DotDict instances.</p> Examples Set up<pre><code>&gt;&gt;&gt; # Imports\n&gt;&gt;&gt; from toolbox_python.dictionaries import DotDict\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a DotDict\n&gt;&gt;&gt; dot_dict = DotDict({\"a\": 1, \"b\": {\"c\": 2}})\n</code></pre> <p>Example 1: Accessing values with dot notation<pre><code>&gt;&gt;&gt; print(dot_dict.a)\n</code></pre> Output<pre><code>1\n</code></pre> <p>Conclusion: Successfully accessed value using dot notation.</p> <p>Example 2: Accessing nested values with dot notation<pre><code>&gt;&gt;&gt; print(dot_dict.b.c)\n</code></pre> Output<pre><code>2\n</code></pre> <p>Conclusion: Successfully accessed nested value using dot notation.</p> <p>Example 3: Setting values with dot notation<pre><code>&gt;&gt;&gt; dot_dict.d = 3\n&gt;&gt;&gt; print(dot_dict.d)\n</code></pre> Output<pre><code>3\n</code></pre> <p>Conclusion: Successfully set value using dot notation.</p> <p>Example 4: Updating nested values with dot notation<pre><code>&gt;&gt;&gt; dot_dict.b.e = 4\n&gt;&gt;&gt; print(dot_dict.b.e)\n</code></pre> Output<pre><code>4\n</code></pre> <p>Conclusion: Successfully updated nested value using dot notation.</p> <p>Example 5: Converting back to regular dict<pre><code>&gt;&gt;&gt; regular_dict = dot_dict.to_dict()\n&gt;&gt;&gt; print(regular_dict)\n</code></pre> Output<pre><code>{'a': 1, 'b': {'c': 2, 'e': 4}, 'd': 3}\n</code></pre> <p>Conclusion: Successfully converted DotDict back to regular dict.</p> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>class DotDict(dict):\n    \"\"\"\n    !!! note \"Summary\"\n        Dictionary subclass that allows dot notation access to keys.\n\n    !!! abstract \"Details\"\n        Nested dictionaries are automatically converted to DotDict instances.\n\n    ???+ example \"Examples\"\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; # Imports\n        &gt;&gt;&gt; from toolbox_python.dictionaries import DotDict\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create a DotDict\n        &gt;&gt;&gt; dot_dict = DotDict({\"a\": 1, \"b\": {\"c\": 2}})\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Accessing values with dot notation\"}\n        &gt;&gt;&gt; print(dot_dict.a)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        1\n        ```\n        !!! success \"Conclusion: Successfully accessed value using dot notation.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Accessing nested values with dot notation\"}\n        &gt;&gt;&gt; print(dot_dict.b.c)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        2\n        ```\n        !!! success \"Conclusion: Successfully accessed nested value using dot notation.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Setting values with dot notation\"}\n        &gt;&gt;&gt; dot_dict.d = 3\n        &gt;&gt;&gt; print(dot_dict.d)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        3\n        ```\n        !!! success \"Conclusion: Successfully set value using dot notation.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Updating nested values with dot notation\"}\n        &gt;&gt;&gt; dot_dict.b.e = 4\n        &gt;&gt;&gt; print(dot_dict.b.e)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        4\n        ```\n        !!! success \"Conclusion: Successfully updated nested value using dot notation.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 5: Converting back to regular dict\"}\n        &gt;&gt;&gt; regular_dict = dot_dict.to_dict()\n        &gt;&gt;&gt; print(regular_dict)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        {'a': 1, 'b': {'c': 2, 'e': 4}, 'd': 3}\n        ```\n        !!! success \"Conclusion: Successfully converted DotDict back to regular dict.\"\n        &lt;/div&gt;\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        dict.__init__(self)\n        d = dict(*args, **kwargs)\n        for key, value in d.items():\n            self[key] = self._convert_value(value)\n\n    def _convert_value(self, value):\n        \"\"\"Convert dictionary values recursively.\"\"\"\n        if isinstance(value, dict):\n            return DotDict(value)\n        elif isinstance(value, list):\n            return list(self._convert_value(item) for item in value)\n        elif isinstance(value, tuple):\n            return tuple(self._convert_value(item) for item in value)\n        elif isinstance(value, set):\n            return set(self._convert_value(item) for item in value)\n        return value\n\n    def __getattr__(self, key) -&gt; Any:\n        \"\"\"Allow dictionary keys to be accessed as attributes.\"\"\"\n        try:\n            return self[key]\n        except KeyError as e:\n            raise AttributeError(f\"Key not found: '{key}'\") from e\n\n    def __setattr__(self, key, value) -&gt; None:\n        \"\"\"Allow setting dictionary keys via attributes.\"\"\"\n        self[key] = value\n\n    def __setitem__(self, key, value) -&gt; None:\n        \"\"\"Intercept item setting to convert dictionaries.\"\"\"\n        dict.__setitem__(self, key, self._convert_value(value))\n\n    def __delitem__(self, key) -&gt; None:\n        \"\"\"Intercept item deletion to remove keys.\"\"\"\n        try:\n            dict.__delitem__(self, key)\n        except KeyError as e:\n            raise KeyError(f\"Key not found: '{key}'.\") from e\n\n    def __delattr__(self, key) -&gt; None:\n        \"\"\"Allow deleting dictionary keys via attributes.\"\"\"\n        try:\n            del self[key]\n        except KeyError as e:\n            raise AttributeError(f\"Key not found: '{key}'\") from e\n\n    def update(self, *args, **kwargs) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Override update to convert new values.\n\n        Parameters:\n            *args:\n                Variable length argument list.\n            **kwargs:\n                Arbitrary keyword arguments.\n\n        Returns:\n            (None):\n                This function does not return a value. It updates the dictionary with new key-value pairs.\n\n        ???+ example \"Examples\"\n            ```pycon {.py .python linenums=\"1\" title=\"Update DotDict\"}\n            &gt;&gt;&gt; dot_dict = DotDict({\"a\": 1, \"b\": 2})\n            &gt;&gt;&gt; dot_dict.update({\"c\": 3, \"d\": {\"e\": 4}})\n            &gt;&gt;&gt; print(dot_dict)\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.sh .shell title=\"Output\"}\n            {'a': 1, 'b': 2, 'c': 3, 'd': {'e': 4}}\n            ```\n            !!! success \"Conclusion: Successfully updated DotDict with new values.\"\n            &lt;/div&gt;\n        \"\"\"\n        for k, v in dict(*args, **kwargs).items():\n            self[k] = v\n\n    def to_dict(self) -&gt; Any:\n        \"\"\"\n        !!! note \"Summary\"\n            Convert back to regular dictionary.\n\n        Returns:\n            (Any):\n                The original dictionary structure, with all nested `#!py DotDict` instances converted back to regular dictionaries.\n\n        ???+ example \"Examples\"\n            ```pycon {.py .python linenums=\"1\" title=\"Convert DotDict to regular dict\"}\n            &gt;&gt;&gt; dot_dict = DotDict({\"a\": 1, \"b\": {\"c\": 2}})\n            &gt;&gt;&gt; regular_dict = dot_dict.to_dict()\n            &gt;&gt;&gt; print(regular_dict)\n            ```\n            &lt;div class=\"result\" markdown&gt;\n            ```{.sh .shell title=\"Output\"}\n            {'a': 1, 'b': {'c': 2}}\n            ```\n            !!! success \"Conclusion: Successfully converted DotDict back to regular dict.\"\n            &lt;/div&gt;\n        \"\"\"\n\n        def _convert_back(obj) -&gt; Any:\n            if isinstance(obj, DotDict):\n                return {k: _convert_back(v) for k, v in obj.items()}\n            elif isinstance(obj, list):\n                return list(_convert_back(item) for item in obj)\n            elif isinstance(obj, tuple):\n                return tuple(_convert_back(item) for item in obj)\n            elif isinstance(obj, set):\n                return set(_convert_back(item) for item in obj)\n            return obj\n\n        return _convert_back(self)\n</code></pre>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.DotDict.__init__","title":"__init__","text":"<pre><code>__init__(*args, **kwargs) -&gt; None\n</code></pre> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    dict.__init__(self)\n    d = dict(*args, **kwargs)\n    for key, value in d.items():\n        self[key] = self._convert_value(value)\n</code></pre>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.DotDict.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(key) -&gt; Any\n</code></pre> <p>Allow dictionary keys to be accessed as attributes.</p> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>def __getattr__(self, key) -&gt; Any:\n    \"\"\"Allow dictionary keys to be accessed as attributes.\"\"\"\n    try:\n        return self[key]\n    except KeyError as e:\n        raise AttributeError(f\"Key not found: '{key}'\") from e\n</code></pre>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.DotDict.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(key, value) -&gt; None\n</code></pre> <p>Allow setting dictionary keys via attributes.</p> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>def __setattr__(self, key, value) -&gt; None:\n    \"\"\"Allow setting dictionary keys via attributes.\"\"\"\n    self[key] = value\n</code></pre>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.DotDict.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value) -&gt; None\n</code></pre> <p>Intercept item setting to convert dictionaries.</p> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>def __setitem__(self, key, value) -&gt; None:\n    \"\"\"Intercept item setting to convert dictionaries.\"\"\"\n    dict.__setitem__(self, key, self._convert_value(value))\n</code></pre>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.DotDict.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key) -&gt; None\n</code></pre> <p>Intercept item deletion to remove keys.</p> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>def __delitem__(self, key) -&gt; None:\n    \"\"\"Intercept item deletion to remove keys.\"\"\"\n    try:\n        dict.__delitem__(self, key)\n    except KeyError as e:\n        raise KeyError(f\"Key not found: '{key}'.\") from e\n</code></pre>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.DotDict.__delattr__","title":"__delattr__","text":"<pre><code>__delattr__(key) -&gt; None\n</code></pre> <p>Allow deleting dictionary keys via attributes.</p> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>def __delattr__(self, key) -&gt; None:\n    \"\"\"Allow deleting dictionary keys via attributes.\"\"\"\n    try:\n        del self[key]\n    except KeyError as e:\n        raise AttributeError(f\"Key not found: '{key}'\") from e\n</code></pre>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.DotDict.update","title":"update","text":"<pre><code>update(*args, **kwargs) -&gt; None\n</code></pre> <p>Summary</p> <p>Override update to convert new values.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value. It updates the dictionary with new key-value pairs.</p> Examples <p>Update DotDict<pre><code>&gt;&gt;&gt; dot_dict = DotDict({\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; dot_dict.update({\"c\": 3, \"d\": {\"e\": 4}})\n&gt;&gt;&gt; print(dot_dict)\n</code></pre> Output<pre><code>{'a': 1, 'b': 2, 'c': 3, 'd': {'e': 4}}\n</code></pre> <p>Conclusion: Successfully updated DotDict with new values.</p> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Override update to convert new values.\n\n    Parameters:\n        *args:\n            Variable length argument list.\n        **kwargs:\n            Arbitrary keyword arguments.\n\n    Returns:\n        (None):\n            This function does not return a value. It updates the dictionary with new key-value pairs.\n\n    ???+ example \"Examples\"\n        ```pycon {.py .python linenums=\"1\" title=\"Update DotDict\"}\n        &gt;&gt;&gt; dot_dict = DotDict({\"a\": 1, \"b\": 2})\n        &gt;&gt;&gt; dot_dict.update({\"c\": 3, \"d\": {\"e\": 4}})\n        &gt;&gt;&gt; print(dot_dict)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        {'a': 1, 'b': 2, 'c': 3, 'd': {'e': 4}}\n        ```\n        !!! success \"Conclusion: Successfully updated DotDict with new values.\"\n        &lt;/div&gt;\n    \"\"\"\n    for k, v in dict(*args, **kwargs).items():\n        self[k] = v\n</code></pre>"},{"location":"code/dictionaries/#toolbox_python.dictionaries.DotDict.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Any\n</code></pre> <p>Summary</p> <p>Convert back to regular dictionary.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The original dictionary structure, with all nested <code>DotDict</code> instances converted back to regular dictionaries.</p> Examples <p>Convert DotDict to regular dict<pre><code>&gt;&gt;&gt; dot_dict = DotDict({\"a\": 1, \"b\": {\"c\": 2}})\n&gt;&gt;&gt; regular_dict = dot_dict.to_dict()\n&gt;&gt;&gt; print(regular_dict)\n</code></pre> Output<pre><code>{'a': 1, 'b': {'c': 2}}\n</code></pre> <p>Conclusion: Successfully converted DotDict back to regular dict.</p> Source code in <code>src/toolbox_python/dictionaries.py</code> <pre><code>def to_dict(self) -&gt; Any:\n    \"\"\"\n    !!! note \"Summary\"\n        Convert back to regular dictionary.\n\n    Returns:\n        (Any):\n            The original dictionary structure, with all nested `#!py DotDict` instances converted back to regular dictionaries.\n\n    ???+ example \"Examples\"\n        ```pycon {.py .python linenums=\"1\" title=\"Convert DotDict to regular dict\"}\n        &gt;&gt;&gt; dot_dict = DotDict({\"a\": 1, \"b\": {\"c\": 2}})\n        &gt;&gt;&gt; regular_dict = dot_dict.to_dict()\n        &gt;&gt;&gt; print(regular_dict)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        {'a': 1, 'b': {'c': 2}}\n        ```\n        !!! success \"Conclusion: Successfully converted DotDict back to regular dict.\"\n        &lt;/div&gt;\n    \"\"\"\n\n    def _convert_back(obj) -&gt; Any:\n        if isinstance(obj, DotDict):\n            return {k: _convert_back(v) for k, v in obj.items()}\n        elif isinstance(obj, list):\n            return list(_convert_back(item) for item in obj)\n        elif isinstance(obj, tuple):\n            return tuple(_convert_back(item) for item in obj)\n        elif isinstance(obj, set):\n            return set(_convert_back(item) for item in obj)\n        return obj\n\n    return _convert_back(self)\n</code></pre>"},{"location":"code/generators/","title":"Generators","text":""},{"location":"code/generators/#toolbox_python.generators","title":"toolbox_python.generators","text":"<p>Summary</p> <p>This module provides functions to generate information as needed. Such functions are typically used to generate data that is not stored in a database or file, but rather computed on-the-fly based on input parameters.</p>"},{"location":"code/generators/#toolbox_python.generators.generate_group_cutoffs","title":"generate_group_cutoffs","text":"<pre><code>generate_group_cutoffs(\n    total_number: int, num_groups: int\n) -&gt; tuple[tuple[int, int], ...]\n</code></pre> <p>Summary</p> <p>Generate group cutoffs for a given total number and number of groups.</p> <p>Details</p> <p>This function divides a total number of items into a specified number of groups, returning a <code>tuple</code> of <code>tuple</code>'s where each inner <code>tuple</code> contains the start and end indices for each group. The last group may contain fewer items if the total number is not evenly divisible by the number of groups.</p> <p>Parameters:</p> Name Type Description Default <code>total_number</code> <code>int</code> <p>The total number of items to be divided into groups.</p> required <code>num_groups</code> <code>int</code> <p>The number of groups to create.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <code>ValueError</code> <p>If <code>total_number</code> is less than 1, or if <code>num_groups</code> is less than 1, or if <code>total_number</code> is less than <code>num_groups</code>. Uses the <code>assert_is_valid</code> function to validate the inputs.</p> <p>Returns:</p> Type Description <code>tuple[tuple[int, int], ...]</code> <p>A tuple of tuples, where each inner tuple contains the start and end indices for each group. The last group may have a different size if the total number is not evenly divisible by the number of groups.</p> Examples Prepare data<pre><code>&gt;&gt;&gt; from toolbox_python.generators import generate_group_cutoffs\n</code></pre> <p>Example 1: Basic usage<pre><code>&gt;&gt;&gt; generate_group_cutoffs(10, 3)\n</code></pre> Output<pre><code>((0, 3), (3, 6), (6, 11))\n</code></pre> <p>Conclusion: Successfully split 10 items into 3 groups.</p> <p>Example 2: Uneven groups<pre><code>&gt;&gt;&gt; generate_group_cutoffs(10, 4)\n</code></pre> Output<pre><code>((0, 3), (3, 6), (6, 9), (9, 11))\n</code></pre> <p>Conclusion: Successfully split 10 items into 4 groups, with the last group having fewer items.</p> <p>Example 3: Single group<pre><code>&gt;&gt;&gt; generate_group_cutoffs(10, 1)\n</code></pre> Output<pre><code>((0, 11),)\n</code></pre> <p>Conclusion: Successfully created a single group containing all items.</p> <p>Example 4: Zero groups<pre><code>&gt;&gt;&gt; generate_group_cutoffs(10, 0)\n</code></pre> Output<pre><code>ValueError: Validation failed: 'num_groups &gt; 0' is not True\n</code></pre> <p>Conclusion: Cannot create groups with zero groups specified.</p> <p>Example 5: Negative total number<pre><code>&gt;&gt;&gt; generate_group_cutoffs(-10, 3)\n</code></pre> Output<pre><code>ValueError: Validation failed: 'total_number &gt; 0' is not True\n</code></pre> <p>Conclusion: Total number must be greater than 0.</p> <p>Example 6: Total number less than groups<pre><code>&gt;&gt;&gt; generate_group_cutoffs(3, 5)\n</code></pre> Output<pre><code>ValueError: Validation failed: 'total_number &gt;= num_groups' is not True\n</code></pre> <p>Conclusion: Total number must be greater than or equal to the number of groups.</p> Source code in <code>src/toolbox_python/generators.py</code> <pre><code>@typechecked\ndef generate_group_cutoffs(\n    total_number: int, num_groups: int\n) -&gt; tuple[tuple[int, int], ...]:\n    \"\"\"\n    !!! note \"Summary\"\n        Generate group cutoffs for a given total number and number of groups.\n\n    !!! details \"Details\"\n        This function divides a total number of items into a specified number of groups, returning a `#!py tuple` of `#!py tuple`'s where each inner `#!py tuple` contains the start and end indices for each group. The last group may contain fewer items if the total number is not evenly divisible by the number of groups.\n\n    Params:\n        total_number (int):\n            The total number of items to be divided into groups.\n        num_groups (int):\n            The number of groups to create.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n        ValueError:\n            If `total_number` is less than 1, or if `num_groups` is less than 1, or if `total_number` is less than `num_groups`. Uses the [`assert_is_valid`][toolbox_python.checkers.assert_is_valid] function to validate the inputs.\n\n    Returns:\n        (tuple[tuple[int, int], ...]):\n            A tuple of tuples, where each inner tuple contains the start and end indices for each group. The last group may have a different size if the total number is not evenly divisible by the number of groups.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Prepare data\"}\n        &gt;&gt;&gt; from toolbox_python.generators import generate_group_cutoffs\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Basic usage\"}\n        &gt;&gt;&gt; generate_group_cutoffs(10, 3)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        ((0, 3), (3, 6), (6, 11))\n        ```\n        !!! success \"Conclusion: Successfully split 10 items into 3 groups.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Uneven groups\"}\n        &gt;&gt;&gt; generate_group_cutoffs(10, 4)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        ((0, 3), (3, 6), (6, 9), (9, 11))\n        ```\n        !!! success \"Conclusion: Successfully split 10 items into 4 groups, with the last group having fewer items.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Single group\"}\n        &gt;&gt;&gt; generate_group_cutoffs(10, 1)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        ((0, 11),)\n        ```\n        !!! success \"Conclusion: Successfully created a single group containing all items.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Zero groups\"}\n        &gt;&gt;&gt; generate_group_cutoffs(10, 0)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        ValueError: Validation failed: 'num_groups &gt; 0' is not True\n        ```\n        !!! failure \"Conclusion: Cannot create groups with zero groups specified.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 5: Negative total number\"}\n        &gt;&gt;&gt; generate_group_cutoffs(-10, 3)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        ValueError: Validation failed: 'total_number &gt; 0' is not True\n        ```\n        !!! failure \"Conclusion: Total number must be greater than 0.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 6: Total number less than groups\"}\n        &gt;&gt;&gt; generate_group_cutoffs(3, 5)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Output\"}\n        ValueError: Validation failed: 'total_number &gt;= num_groups' is not True\n        ```\n        !!! failure \"Conclusion: Total number must be greater than or equal to the number of groups.\"\n        &lt;/div&gt;\n    \"\"\"\n\n    # Validations\n    assert_is_valid(total_number, \"&gt;\", 0)\n    assert_is_valid(num_groups, \"&gt;\", 0)\n    assert_is_valid(total_number, \"&gt;=\", num_groups)\n\n    # Calculate the size of each group\n    group_size: int = total_number // num_groups\n\n    # List to store all group cutoffs\n    cutoffs: list[tuple[int, int]] = []\n\n    # Calculate the number of items that will be in the last group\n    current_start: int = 0\n\n    # Loop through the number of groups to calculate start and end indices\n    for group in range(num_groups):\n\n        # For the last group, end is total_number + 1\n        if group == num_groups - 1:\n            current_end: int = total_number + 1\n        else:\n            current_end: int = current_start + group_size\n\n        # Add the current group cutoff to the list\n        cutoffs.append((current_start, current_end))\n\n        # Update the start index for the next group\n        current_start: int = current_end\n\n    # Convert the list to a tuple of tuples\n    return tuple(cutoffs)\n</code></pre>"},{"location":"code/lists/","title":"Lists","text":""},{"location":"code/lists/#toolbox_python.lists","title":"toolbox_python.lists","text":"<p>Summary</p> <p>The <code>lists</code> module is used to manipulate and enhance Python <code>list</code>'s.</p> <p>Details</p> <p>Note that functions in this module will only take-in and manipulate existing <code>list</code> objects, and also output <code>list</code> objects. It will not sub-class the base <code>list</code> object, or create new '<code>list</code>-like' objects. It will always maintain pure python types at it's core.</p>"},{"location":"code/lists/#toolbox_python.lists.flatten","title":"flatten","text":"<pre><code>flatten(\n    list_of_lists: Union[scalar, collection],\n    base_type: Optional[type] = None,\n    levels: Optional[int] = None,\n) -&gt; any_list\n</code></pre> <p>Summary</p> <p>For a given <code>list</code> of <code>list</code>'s, flatten it out to be a single <code>list</code>.</p> Details <p>Under the hood, this function will call the <code>more_itertools.collapse()</code> function. The difference between this function and the <code>more_itertools.collapse()</code> function is that the one from <code>more_itertools</code> will return a <code>chain</code> object, not a <code>list</code> object. So, all we do here is call the <code>more_itertools.collapse()</code> function, then parse the result in to a <code>list()</code> function to ensure that the result is always a <code>list</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>list_of_lists</code> <code>list[any_list]</code> <p>The input <code>list</code> of <code>list</code>'s that you'd like to flatten to a single-level <code>list</code>.</p> required <code>base_type</code> <code>Optional[type]</code> <p>Binary and text strings are not considered iterable and will not be collapsed. To avoid collapsing other types, specify <code>base_type</code>. Defaults to <code>None</code>.</p> <code>None</code> <code>levels</code> <code>Optional[int]</code> <p>Specify <code>levels</code> to stop flattening after a certain nested level. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>any_list</code> <p>The updated <code>list</code>.</p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.lists import flatten\n</code></pre> <p>Example 1: Basic list, same input &amp; output<pre><code>&gt;&gt;&gt; print(flatten([0, 1, 2, 3]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 2: List containing two lists<pre><code>&gt;&gt;&gt; print(flatten([[0, 1], [2, 3]]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 3: List containing a list and other data<pre><code>&gt;&gt;&gt; print(flatten([0, 1, [2, 3]]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 4: List containing two lists and other data<pre><code>&gt;&gt;&gt; print(flatten([[0, 1], [2, 3], 4, 5]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 5: List containing a list, a tuple, and other data<pre><code>&gt;&gt;&gt; print(flatten([[0, 1], (2, 3), 4, 5]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 6: List containing up to three levels deep<pre><code>&gt;&gt;&gt; print(flatten([[0, 1], [2, 3, [4, 5]]]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 7: List containing up to three levels deep, plus other data<pre><code>&gt;&gt;&gt; print(flatten([[0, 1], [2, 3, [4, 5]], 6, 7]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5, 6, 7]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 8: List containing up to four levels deep<pre><code>&gt;&gt;&gt; print(flatten([[0, 1], [2, 3, [4, [5]]]]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5]\n</code></pre> <p>Conclusion: Successful flattening.</p> See Also <ul> <li><code>more_itertools</code></li> <li><code>more_itertools.collapse()</code></li> </ul> Source code in <code>src/toolbox_python/lists.py</code> <pre><code>@typechecked\ndef flatten(\n    list_of_lists: Union[scalar, collection],\n    base_type: Optional[type] = None,\n    levels: Optional[int] = None,\n) -&gt; any_list:\n    \"\"\"\n    !!! note \"Summary\"\n        For a given `#!py list` of `#!py list`'s, flatten it out to be a single `#!py list`.\n\n    ???+ info \"Details\"\n        Under the hood, this function will call the [`#!py more_itertools.collapse()`][more_itertools.collapse] function. The difference between this function and the [`#!py more_itertools.collapse()`][more_itertools.collapse] function is that the one from [`#!py more_itertools`][more_itertools] will return a `chain` object, not a `list` object. So, all we do here is call the [`#!py more_itertools.collapse()`][more_itertools.collapse] function, then parse the result in to a `#!py list()` function to ensure that the result is always a `#!py list` object.\n\n        [more_itertools]: https://more-itertools.readthedocs.io/en/stable/api.html\n        [more_itertools.collapse]: https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse\n\n    Params:\n        list_of_lists (list[any_list]):\n            The input `#!py list` of `#!py list`'s that you'd like to flatten to a single-level `#!py list`.\n        base_type (Optional[type], optional):\n            Binary and text strings are not considered iterable and will not be collapsed. To avoid collapsing other types, specify `base_type`.&lt;br&gt;\n            Defaults to `#!py None`.\n        levels (Optional[int], optional):\n            Specify `levels` to stop flattening after a certain nested level.&lt;br&gt;\n            Defaults to `#!py None`.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (any_list):\n            The updated `#!py list`.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.lists import flatten\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Basic list, same input &amp; output\"}\n        &gt;&gt;&gt; print(flatten([0, 1, 2, 3]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: List containing two lists\"}\n        &gt;&gt;&gt; print(flatten([[0, 1], [2, 3]]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: List containing a list and other data\"}\n        &gt;&gt;&gt; print(flatten([0, 1, [2, 3]]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: List containing two lists and other data\"}\n        &gt;&gt;&gt; print(flatten([[0, 1], [2, 3], 4, 5]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 5: List containing a list, a tuple, and other data\"}\n        &gt;&gt;&gt; print(flatten([[0, 1], (2, 3), 4, 5]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 6: List containing up to three levels deep\"}\n        &gt;&gt;&gt; print(flatten([[0, 1], [2, 3, [4, 5]]]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 7: List containing up to three levels deep, plus other data\"}\n        &gt;&gt;&gt; print(flatten([[0, 1], [2, 3, [4, 5]], 6, 7]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5, 6, 7]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 8: List containing up to four levels deep\"}\n        &gt;&gt;&gt; print(flatten([[0, 1], [2, 3, [4, [5]]]]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`more_itertools`](https://more-itertools.readthedocs.io/en/stable/api.html)\n        - [`more_itertools.collapse()`](https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.collapse)\n    \"\"\"\n    return list(\n        itertools_collapse(\n            iterable=list_of_lists,  # type: ignore\n            base_type=base_type,\n            levels=levels,\n        )\n    )\n</code></pre>"},{"location":"code/lists/#toolbox_python.lists.flat_list","title":"flat_list","text":"<pre><code>flat_list(*inputs: Any) -&gt; any_list\n</code></pre> <p>Summary</p> <p>Take in any number of inputs, and output them all in to a single flat <code>list</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Any</code> <p>Any input.</p> <code>()</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>any_list</code> <p>The input having been coerced to a single flat <code>list</code>.</p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.lists import flat_list\n</code></pre> <p>Example 1: Basic input &amp; output<pre><code>&gt;&gt;&gt; print(flat_list(0, 1, 2, 3))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 2: Multiple lists<pre><code>&gt;&gt;&gt; print(flat_list([0, 1], [2, 3]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 3: List and other data<pre><code>&gt;&gt;&gt; print(flat_list(0, 1, [2, 3]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 4: Multiple lists and other data<pre><code>&gt;&gt;&gt; print(flat_list([0, 1], [2, 3], 4, 5))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 5: List and a tuple and other data<pre><code>&gt;&gt;&gt; print(flat_list([0, 1], (2, 3), 4, 5))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 6: List and a nested list<pre><code>&gt;&gt;&gt; print(flat_list([0, 1], [2, 3, [4, 5]]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 7: List and a nested list and other data<pre><code>&gt;&gt;&gt; print(flat_list([0, 1], [2, 3, [4, 5]], 6, 7))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5, 6, 7]\n</code></pre> <p>Conclusion: Successful flattening.</p> <p>Example 8: Deep nested lists<pre><code>&gt;&gt;&gt; print(flat_list([0, 1], [2, 3, [4, [5]]]))\n</code></pre> Terminal<pre><code>[0, 1, 2, 3, 4, 5]\n</code></pre> <p>Conclusion: Successful flattening.</p> See Also <ul> <li><code>flatten()</code></li> </ul> Source code in <code>src/toolbox_python/lists.py</code> <pre><code>@typechecked\ndef flat_list(*inputs: Any) -&gt; any_list:\n    \"\"\"\n    !!! note \"Summary\"\n        Take in any number of inputs, and output them all in to a single flat `#!py list`.\n\n    Params:\n        inputs (Any):\n            Any input.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (any_list):\n            The input having been coerced to a single flat `#!py list`.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.lists import flat_list\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Basic input &amp; output\"}\n        &gt;&gt;&gt; print(flat_list(0, 1, 2, 3))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Multiple lists\"}\n        &gt;&gt;&gt; print(flat_list([0, 1], [2, 3]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: List and other data\"}\n        &gt;&gt;&gt; print(flat_list(0, 1, [2, 3]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Multiple lists and other data\"}\n        &gt;&gt;&gt; print(flat_list([0, 1], [2, 3], 4, 5))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 5: List and a tuple and other data\"}\n        &gt;&gt;&gt; print(flat_list([0, 1], (2, 3), 4, 5))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 6: List and a nested list\"}\n        &gt;&gt;&gt; print(flat_list([0, 1], [2, 3, [4, 5]]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 7: List and a nested list and other data\"}\n        &gt;&gt;&gt; print(flat_list([0, 1], [2, 3, [4, 5]], 6, 7))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5, 6, 7]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 8: Deep nested lists\"}\n        &gt;&gt;&gt; print(flat_list([0, 1], [2, 3, [4, [5]]]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [0, 1, 2, 3, 4, 5]\n        ```\n        !!! success \"Conclusion: Successful flattening.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`flatten()`][toolbox_python.lists.flatten]\n    \"\"\"\n    return flatten(list(inputs))\n</code></pre>"},{"location":"code/lists/#toolbox_python.lists.product","title":"product","text":"<pre><code>product(*iterables) -&gt; list[any_tuple]\n</code></pre> <p>Summary</p> <p>For a given number of <code>iterables</code>, perform a cartesian product on them, and return the result as a list.</p> Details <p>Under the hood, this function will call the <code>itertools.product()</code> function. The difference between this function and the <code>itertools.product()</code> function is that the one from <code>itertools</code> will return a <code>product</code> object, not a <code>list</code> object. So, all we do here is call the <code>itertools.product()</code> function, then parse the result in to a <code>list()</code> function to ensure that the result is always a <code>list</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>iterables</code> <code>Any</code> <p>The input <code>iterables</code> that you'd like to expand out.</p> <code>()</code> <p>Returns:</p> Type Description <code>list[tuple[Any, ...]]</code> <p>The updated <code>list</code> list of <code>tuple</code>'s representing the Cartesian product of the provided iterables.</p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.lists import product\n</code></pre> <p>Example 1: Basic input &amp; output<pre><code>&gt;&gt;&gt; print(product([1], [11], [111]))\n</code></pre> Terminal<pre><code>[\n    (1, 11, 111),\n]\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Example 2: Multiple lists<pre><code>&gt;&gt;&gt; print(product([1, 2], [11], [111]))\n</code></pre> Terminal<pre><code>[\n    (1, 11, 111),\n    (2, 11, 111),\n]\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Example 3: List and other data<pre><code>&gt;&gt;&gt; print(product([1, 2], [11], [111, 222]))\n</code></pre> Terminal<pre><code>[\n    (1, 11, 111),\n    (1, 11, 222),\n    (2, 11, 111),\n    (2, 11, 222),\n]\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Example 4: Multiple lists and other data<pre><code>&gt;&gt;&gt; print(product([1, 2], [11, 22], [111, 222]))\n</code></pre> Terminal<pre><code>[\n    (1, 11, 111),\n    (1, 11, 222),\n    (1, 22, 111),\n    (1, 22, 222),\n    (2, 11, 111),\n    (2, 11, 222),\n    (2, 22, 111),\n    (2, 22, 222),\n]\n</code></pre> <p>Conclusion: Successful conversion.</p> See Also <ul> <li>itertools</li> <li>itertools.product()</li> </ul> Source code in <code>src/toolbox_python/lists.py</code> <pre><code>def product(*iterables) -&gt; list[any_tuple]:\n    \"\"\"\n    !!! note \"Summary\"\n        For a given number of `#!py iterables`, perform a cartesian product on them, and return the result as a list.\n\n    ???+ info \"Details\"\n        Under the hood, this function will call the [`#!py itertools.product()`][itertools.product] function. The difference between this function and the [`#!py itertools.product()`][itertools.product] function is that the one from [`#!py itertools`][itertools] will return a `product` object, not a `list` object. So, all we do here is call the [`#!py itertools.product()`][itertools.product] function, then parse the result in to a `#!py list()` function to ensure that the result is always a `#!py list` object.\n\n        [itertools]: https://docs.python.org/3/library/itertools.html\n        [itertools.product]: https://docs.python.org/3/library/itertools.html#itertools.product\n\n    Params:\n        iterables (Any):\n            The input `#!py iterables` that you'd like to expand out.\n\n    Returns:\n        (list[tuple[Any, ...]]):\n            The updated `#!py list` list of `#!py tuple`'s representing the Cartesian product of the provided iterables.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.lists import product\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Basic input &amp; output\"}\n        &gt;&gt;&gt; print(product([1], [11], [111]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [\n            (1, 11, 111),\n        ]\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Multiple lists\"}\n        &gt;&gt;&gt; print(product([1, 2], [11], [111]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [\n            (1, 11, 111),\n            (2, 11, 111),\n        ]\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: List and other data\"}\n        &gt;&gt;&gt; print(product([1, 2], [11], [111, 222]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [\n            (1, 11, 111),\n            (1, 11, 222),\n            (2, 11, 111),\n            (2, 11, 222),\n        ]\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Multiple lists and other data\"}\n        &gt;&gt;&gt; print(product([1, 2], [11, 22], [111, 222]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [\n            (1, 11, 111),\n            (1, 11, 222),\n            (1, 22, 111),\n            (1, 22, 222),\n            (2, 11, 111),\n            (2, 11, 222),\n            (2, 22, 111),\n            (2, 22, 222),\n        ]\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [itertools](https://docs.python.org/3/library/itertools.html)\n        - [itertools.product()](https://docs.python.org/3/library/itertools.html#itertools.product)\n    \"\"\"\n    return list(itertools_product(*iterables))\n</code></pre>"},{"location":"code/output/","title":"Output","text":""},{"location":"code/output/#toolbox_python.output","title":"toolbox_python.output","text":"<p>Summary</p> <p>The <code>output</code> module is for streamlining how data is outputted. This includes <code>print()</code>'ing to the terminal and <code>log()</code>'ing to files.</p>"},{"location":"code/output/#toolbox_python.output.print_or_log_output","title":"print_or_log_output","text":"<pre><code>print_or_log_output(\n    message: str,\n    print_or_log: Literal[\"print\", \"log\"] = \"print\",\n    log: Optional[Logger] = None,\n    log_level: Optional[log_levels] = None,\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Determine whether to <code>print()</code> or <code>log()</code> a given <code>message</code>.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The <code>message</code> to be processed.</p> required <code>print_or_log</code> <code>Optional[Literal['print', 'log']]</code> <p>The option for what to do with the <code>message</code>. Defaults to <code>\"print\"</code>.</p> <code>'print'</code> <code>log</code> <code>Optional[Logger]</code> <p>If <code>print_or_log==\"log\"</code>, then this parameter must contain the <code>Logger</code> object to be processed, otherwise it will raise an <code>AssertError</code>. Defaults to <code>None</code>.</p> <code>None</code> <code>log_level</code> <code>Optional[_log_levels]</code> <p>If <code>print_or_log==\"log\"</code>, then this parameter must contain the required log level for the <code>message</code>. Must be one of the log-levels available in the <code>logging</code> module. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <code>AssertError</code> <p>If <code>print_or_log==\"log\"</code> and <code>log</code> is not an instance of <code>Logger</code>.</p> <p>Returns:</p> Type Description <code>None</code> <p>Nothing is returned. Only printed or logged.</p> Examples Set up data for examples<pre><code>&gt;&gt;&gt; from toolbox_python.output import print_or_log_output\n&gt;&gt;&gt; import logging\n&gt;&gt;&gt; logging.basicConfig(filename=\"logs.log\", encoding=\"utf-8\")\n&gt;&gt;&gt; log = logging.getLogger(\"root\")\n&gt;&gt;&gt; default_message = \"This is a\"\n</code></pre> <p>Example 1: Print output<pre><code>&gt;&gt;&gt; print_or_log_output(\n...     message=f\"{default_message} print\",\n...     print_or_log=\"print\",\n... )\n</code></pre> Terminal<pre><code>This is a print\n</code></pre> <p>Conclusion: Successfully printed the message.</p> <p>Example 2: Log `info`<pre><code>&gt;&gt;&gt; print_or_log_output(\n...     message=f\"{default_message}n info\",\n...     print_or_log=\"log\",\n...     log=log,\n...     log_level=\"info\",\n... )\n</code></pre> logs.log<pre><code>INFO:root:This is an info\n</code></pre> <p>Conclusion: Successfully logged the message.</p> <p>Example 3: Log `debug`<pre><code>&gt;&gt;&gt; print_or_log_output(\n...     message=f\"{default_message} debug\",\n...     print_or_log=\"log\",\n...     log=log,\n...     log_level=\"debug\",\n... )\n</code></pre> logs.log<pre><code>INFO:root:This is an info\nDEBUG:root:This is a debug\n</code></pre> <p>Conclusion: Successfully added message to logs.</p> <p>Note: This logging structure will continue for every new call to <code>print_or_log_output()</code> when <code>print_or_log=\"log\"</code>, and the <code>log</code> and <code>log_level</code> parameters are valid.</p> <p>Example 7: Invalid `print_or_log` input<pre><code>&gt;&gt;&gt; print_or_log_output(\n...     message=f\"{default_message} invalid\",\n...     print_or_log=\"error\",\n... )\n</code></pre> Terminal<pre><code>TypeError: ...\n</code></pre> <p>Conclusion: <code>print_or_log</code> can only have the string values <code>\"print\"</code> or <code>\"log\"</code>.</p> <p>Example 8: Invalid `log` input<pre><code>&gt;&gt;&gt; print_or_log_output(\n...     message=f\"{default_message} invalid\",\n...     print_or_log=\"log\",\n...     log=None,\n...     log_level=\"info\",\n... )\n</code></pre> Terminal<pre><code>AssertionError: When `print_or_log=='log'` then `log` must be type `Logger`. Here, you have parsed: '&lt;class 'NoneType'&gt;'\n</code></pre> <p>Conclusion: When <code>print_or_log=\"log\"</code> then <code>log</code> must be an instance of <code>Logger</code>.</p> <p>Example 9: Invalid `log_level` input<pre><code>&gt;&gt;&gt; print_or_log_output(\n...     message=f\"{default_message} invalid\",\n...     print_or_log=\"log\",\n...     log=log,\n...     log_level=\"invalid\",\n... )\n</code></pre> Terminal<pre><code>TypeError: ...\n</code></pre> <p>Conclusion: <code>log_level</code> must be a valid log level from the <code>logging</code> module.</p> Source code in <code>src/toolbox_python/output.py</code> <pre><code>@typechecked\ndef print_or_log_output(\n    message: str,\n    print_or_log: Literal[\"print\", \"log\"] = \"print\",\n    log: Optional[Logger] = None,\n    log_level: Optional[log_levels] = None,\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Determine whether to `#!py print()` or `#!py log()` a given `message`.\n\n    Params:\n        message (str):\n            The `message` to be processed.\n        print_or_log (Optional[Literal[\"print\", \"log\"]], optional):\n            The option for what to do with the `message`.&lt;br&gt;\n            Defaults to `#!py \"print\"`.\n        log (Optional[Logger], optional):\n            If `#!py print_or_log==\"log\"`, then this parameter must contain the `#!py Logger` object to be processed,\n            otherwise it will raise an `#!py AssertError`.&lt;br&gt;\n            Defaults to `#!py None`.\n        log_level (Optional[_log_levels], optional):\n            If `#!py print_or_log==\"log\"`, then this parameter must contain the required log level for the `message`.\n            Must be one of the log-levels available in the `#!py logging` module.&lt;br&gt;\n            Defaults to `#!py None`.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n        AssertError:\n            If `#!py print_or_log==\"log\"` and `#!py log` is not an instance of `#!py Logger`.\n\n    Returns:\n        (None):\n            Nothing is returned. Only printed or logged.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up data for examples\"}\n        &gt;&gt;&gt; from toolbox_python.output import print_or_log_output\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt; logging.basicConfig(filename=\"logs.log\", encoding=\"utf-8\")\n        &gt;&gt;&gt; log = logging.getLogger(\"root\")\n        &gt;&gt;&gt; default_message = \"This is a\"\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Print output\"}\n        &gt;&gt;&gt; print_or_log_output(\n        ...     message=f\"{default_message} print\",\n        ...     print_or_log=\"print\",\n        ... )\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        This is a print\n        ```\n        !!! success \"Conclusion: Successfully printed the message.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Log `info`\"}\n        &gt;&gt;&gt; print_or_log_output(\n        ...     message=f\"{default_message}n info\",\n        ...     print_or_log=\"log\",\n        ...     log=log,\n        ...     log_level=\"info\",\n        ... )\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.log .log title=\"logs.log\"}\n        INFO:root:This is an info\n        ```\n        !!! success \"Conclusion: Successfully logged the message.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Log `debug`\"}\n        &gt;&gt;&gt; print_or_log_output(\n        ...     message=f\"{default_message} debug\",\n        ...     print_or_log=\"log\",\n        ...     log=log,\n        ...     log_level=\"debug\",\n        ... )\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.log .log title=\"logs.log\"}\n        INFO:root:This is an info\n        DEBUG:root:This is a debug\n        ```\n        !!! success \"Conclusion: Successfully added message to logs.\"\n        !!! observation \"Note: This logging structure will continue for every new call to `print_or_log_output()` when `print_or_log=\"log\"`, and the `log` and `log_level` parameters are valid.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 7: Invalid `print_or_log` input\"}\n        &gt;&gt;&gt; print_or_log_output(\n        ...     message=f\"{default_message} invalid\",\n        ...     print_or_log=\"error\",\n        ... )\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        TypeError: ...\n        ```\n        !!! failure \"Conclusion: `print_or_log` can only have the string values `\"print\"` or `\"log\"`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 8: Invalid `log` input\"}\n        &gt;&gt;&gt; print_or_log_output(\n        ...     message=f\"{default_message} invalid\",\n        ...     print_or_log=\"log\",\n        ...     log=None,\n        ...     log_level=\"info\",\n        ... )\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        AssertionError: When `print_or_log=='log'` then `log` must be type `Logger`. Here, you have parsed: '&lt;class 'NoneType'&gt;'\n        ```\n        !!! failure \"Conclusion: When `print_or_log=\"log\"` then `#!py log` must be an instance of `#!py Logger`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 9: Invalid `log_level` input\"}\n        &gt;&gt;&gt; print_or_log_output(\n        ...     message=f\"{default_message} invalid\",\n        ...     print_or_log=\"log\",\n        ...     log=log,\n        ...     log_level=\"invalid\",\n        ... )\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        TypeError: ...\n        ```\n        !!! failure \"Conclusion: `log_level` must be a valid log level from the `logging` module.\"\n        &lt;/div&gt;\n    \"\"\"\n\n    # Early exit when printing the message\n    if print_or_log == \"print\":\n        print(message)\n        return None\n\n    # Check in put for logging\n    if not is_type(log, Logger):\n        raise TypeError(\n            f\"When `print_or_log=='log'` then `log` must be type `Logger`. \"\n            f\"Here, you have parsed: '{type(log)}'\"\n        )\n    if log_level is None:\n        raise ValueError(\n            f\"When `print_or_log=='log'` then `log_level` must be parsed \"\n            f\"with a valid value from: {log_levels}.\"\n        )\n\n    # Assertions to \u007fkeep `mypy` happy\n    assert log is not None\n    assert log_level is not None\n\n    # Do logging\n    log.log(\n        level=_nameToLevel[log_level.upper()],\n        msg=message,\n    )\n</code></pre>"},{"location":"code/output/#toolbox_python.output.list_columns","title":"list_columns","text":"<pre><code>list_columns(\n    obj: Union[any_list, any_set, any_tuple, Generator],\n    cols_wide: int = 4,\n    columnwise: bool = True,\n    gap: int = 4,\n    print_output: Literal[False] = False,\n) -&gt; str\n</code></pre><pre><code>list_columns(\n    obj: Union[any_list, any_set, any_tuple, Generator],\n    cols_wide: int = 4,\n    columnwise: bool = True,\n    gap: int = 4,\n    print_output: Literal[True] = True,\n) -&gt; None\n</code></pre> <pre><code>list_columns(\n    obj: Union[any_list, any_set, any_tuple, Generator],\n    cols_wide: int = 4,\n    columnwise: bool = True,\n    gap: int = 4,\n    print_output: bool = False,\n) -&gt; Optional[str]\n</code></pre> <p>Summary</p> <p>Print the given list in evenly-spaced columns.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>list</code> <p>The list to be formatted.</p> required <code>cols_wide</code> <code>int</code> <p>The number of columns in which the list should be formatted. Defaults to: <code>4</code>.</p> <code>4</code> <code>columnwise</code> <code>bool</code> <p>Whether or not to print columnwise or rowwise.</p> <ul> <li><code>True</code>: Will be formatted column-wise.</li> <li><code>False</code>: Will be formatted row-wise.</li> </ul> <p>Defaults to: <code>True</code>.</p> <code>True</code> <code>gap</code> <code>int</code> <p>The number of spaces that should separate the longest column item/s from the next column. This is the effective spacing between columns based on the maximum <code>len()</code> of the list items. Defaults to: <code>4</code>.</p> <code>4</code> <code>print_output</code> <code>bool</code> <p>Whether or not to print the output to the terminal.</p> <ul> <li><code>True</code>: Will print and return.</li> <li><code>False</code>: Will not print; only return.</li> </ul> <p>Defaults to: <code>True</code>.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <code>TypeError</code> <p>If <code>obj</code> is not a valid type. Must be one of: <code>list</code>, <code>set</code>, <code>tuple</code>, or <code>Generator</code>.</p> <code>ValueError</code> <p>If <code>cols_wide</code> is not greater than <code>0</code>, or if <code>gap</code> is not greater than <code>0</code>.</p> <p>Returns:</p> Name Type Description <code>printer</code> <code>Optional[str]</code> <p>The formatted string object.</p> Examples Set up<pre><code>&gt;&gt;&gt; # Imports\n&gt;&gt;&gt; from toolbox_python.output import list_columns\n&gt;&gt;&gt; import requests\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define function to fetch list of words\n&gt;&gt;&gt; def get_list_of_words(num_words: int = 100):\n...     word_url = \"https://www.mit.edu/~ecprice/wordlist.10000\"\n...     response = requests.get(word_url)\n...     words = response.content.decode().splitlines()\n...     return words[:num_words]\n...\n</code></pre> <p>Example 1: Default parameters<pre><code>&gt;&gt;&gt; list_columns(get_list_of_words(4 * 5))\n</code></pre> Terminal<pre><code>a             abandoned     able          abraham\naa            abc           aboriginal    abroad\naaa           aberdeen      abortion      abs\naaron         abilities     about         absence\nab            ability       above         absent\n</code></pre> <p>Conclusion: Successfully printed the list in columns.</p> <p>Example 2: Columnwise with 2 columns<pre><code>&gt;&gt;&gt; list_columns(\n...     get_list_of_words(5),\n...     cols_wide=2,\n...     columnwise=True,\n... )\n</code></pre> Terminal<pre><code>a        aaron\naa       ab\naaa\n</code></pre> <p>Conclusion: Successfully printed the list in columns.</p> <p>Example 3: Rowwise with 3 columns<pre><code>&gt;&gt;&gt; list_columns(\n...     get_list_of_words(4 * 3),\n...     columnwise=False,\n...     cols_wide=3,\n...     print_output=True,\n... )\n</code></pre> Terminal<pre><code>a             aa            aaa\naaron         ab            abandoned\nabc           aberdeen      abilities\nability       able          aboriginal\n</code></pre> <p>Conclusion: Successfully printed the list in rows.</p> <p>Example 4: Rowwise with 2 columns, no print output<pre><code>&gt;&gt;&gt; output = list_columns(\n...     get_list_of_words(4 * 2),\n...     columnwise=False,\n...     cols_wide=2,\n...     print_output=False,\n... )\n&gt;&gt;&gt; print(output)\n</code></pre> Terminal<pre><code>a            aa\naaa          aaron\nab           abandoned\nabc          aberdeen\n</code></pre> <p>Conclusion: Successfully returned the formatted string.</p> Credit <p>Full credit goes to: https://stackoverflow.com/questions/1524126/how-to-print-a-list-more-nicely#answer-36085705</p> Source code in <code>src/toolbox_python/output.py</code> <pre><code>@typechecked\ndef list_columns(\n    obj: Union[any_list, any_set, any_tuple, Generator],\n    cols_wide: int = 4,\n    columnwise: bool = True,\n    gap: int = 4,\n    print_output: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"\n    !!! note \"Summary\"\n        Print the given list in evenly-spaced columns.\n\n    Params:\n        obj (list):\n            The list to be formatted.\n\n        cols_wide (int, optional):\n            The number of columns in which the list should be formatted.&lt;br&gt;\n            Defaults to: `#!py 4`.\n\n        columnwise (bool, optional):\n            Whether or not to print columnwise or rowwise.\n\n            - `#!py True`: Will be formatted column-wise.\n            - `#!py False`: Will be formatted row-wise.\n\n            Defaults to: `#!py True`.\n\n        gap (int, optional):\n            The number of spaces that should separate the longest column\n            item/s from the next column. This is the effective spacing\n            between columns based on the maximum `#!py len()` of the list items.&lt;br&gt;\n            Defaults to: `#!py 4`.\n\n        print_output (bool, optional):\n            Whether or not to print the output to the terminal.\n\n            - `#!py True`: Will print and return.\n            - `#!py False`: Will not print; only return.\n\n            Defaults to: `#!py True`.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n        TypeError:\n            If `#!py obj` is not a valid type. Must be one of: `#!py list`, `#!py set`, `#!py tuple`, or `#!py Generator`.\n        ValueError:\n            If `#!py cols_wide` is not greater than `0`, or if `#!py gap` is not greater than `0`.\n\n    Returns:\n        printer (Optional[str]):\n            The formatted string object.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; # Imports\n        &gt;&gt;&gt; from toolbox_python.output import list_columns\n        &gt;&gt;&gt; import requests\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Define function to fetch list of words\n        &gt;&gt;&gt; def get_list_of_words(num_words: int = 100):\n        ...     word_url = \"https://www.mit.edu/~ecprice/wordlist.10000\"\n        ...     response = requests.get(word_url)\n        ...     words = response.content.decode().splitlines()\n        ...     return words[:num_words]\n        ...\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Default parameters\"}\n        &gt;&gt;&gt; list_columns(get_list_of_words(4 * 5))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        a             abandoned     able          abraham\n        aa            abc           aboriginal    abroad\n        aaa           aberdeen      abortion      abs\n        aaron         abilities     about         absence\n        ab            ability       above         absent\n        ```\n        !!! success \"Conclusion: Successfully printed the list in columns.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Columnwise with 2 columns\"}\n        &gt;&gt;&gt; list_columns(\n        ...     get_list_of_words(5),\n        ...     cols_wide=2,\n        ...     columnwise=True,\n        ... )\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        a        aaron\n        aa       ab\n        aaa\n        ```\n        !!! success \"Conclusion: Successfully printed the list in columns.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Rowwise with 3 columns\"}\n        &gt;&gt;&gt; list_columns(\n        ...     get_list_of_words(4 * 3),\n        ...     columnwise=False,\n        ...     cols_wide=3,\n        ...     print_output=True,\n        ... )\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        a             aa            aaa\n        aaron         ab            abandoned\n        abc           aberdeen      abilities\n        ability       able          aboriginal\n        ```\n        !!! success \"Conclusion: Successfully printed the list in rows.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Rowwise with 2 columns, no print output\"}\n        &gt;&gt;&gt; output = list_columns(\n        ...     get_list_of_words(4 * 2),\n        ...     columnwise=False,\n        ...     cols_wide=2,\n        ...     print_output=False,\n        ... )\n        &gt;&gt;&gt; print(output)\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.txt .text title=\"Terminal\"}\n        a            aa\n        aaa          aaron\n        ab           abandoned\n        abc          aberdeen\n        ```\n        !!! success \"Conclusion: Successfully returned the formatted string.\"\n        &lt;/div&gt;\n\n    ??? Success \"Credit\"\n        Full credit goes to:&lt;br&gt;\n        https://stackoverflow.com/questions/1524126/how-to-print-a-list-more-nicely#answer-36085705\n    \"\"\"\n\n    # Validations\n    assert_is_type(obj, (list, set, tuple, Generator))\n    assert_all_is_type((cols_wide, gap), int)\n    assert_all_is_type((columnwise, print_output), bool)\n    assert_is_valid(cols_wide, \"&gt;\", 0)\n    assert_is_valid(gap, \"&gt;\", 0)\n\n    # Prepare the string representation of the object\n    string_list: str_list = [str(item) for item in obj]\n    cols_wide = min(cols_wide, len(string_list))\n    max_len: int = max(len(item) for item in string_list)\n\n    # Adjust column width if column-wise output\n    if columnwise:\n        cols_wide = int(ceil(len(string_list) / cols_wide))\n\n    # Segment the list into chunks\n    segmented_list: list[str_list] = [\n        string_list[index : index + cols_wide]\n        for index in range(0, len(string_list), cols_wide)\n    ]\n\n    # Ensure the last segment has the correct number of columns\n    if columnwise:\n        if len(segmented_list[-1]) != cols_wide:\n            segmented_list[-1].extend(\n                [\"\"] * (len(string_list) - len(segmented_list[-1]))\n            )\n        combined_list: Union[list[str_list], Any] = zip(*segmented_list)\n    else:\n        combined_list = segmented_list\n\n    # Create the formatted string with proper spacing\n    printer: str = \"\\n\".join(\n        [\n            \"\".join([element.ljust(max_len + gap) for element in group])\n            for group in combined_list\n        ]\n    )\n\n    # Print the output if requested\n    if print_output:\n        print(printer)\n    return printer\n</code></pre>"},{"location":"code/retry/","title":"Retry","text":""},{"location":"code/retry/#toolbox_python.retry","title":"toolbox_python.retry","text":"<p>Summary</p> <p>The <code>retry</code> module is for enabling automatic retrying of a given function when a specific <code>Exception</code> is thrown.</p>"},{"location":"code/retry/#toolbox_python.retry.retry","title":"retry","text":"<pre><code>retry(\n    exceptions: _exceptions = Exception,\n    tries: int = 1,\n    delay: int = 0,\n    print_or_log: Literal[\"print\"] = \"print\",\n) -&gt; Callable[[Callable[..., R]], Callable[..., R]]\n</code></pre><pre><code>retry(\n    exceptions: _exceptions = Exception,\n    tries: int = 1,\n    delay: int = 0,\n    print_or_log: Literal[\"log\"] = \"log\",\n) -&gt; Callable[[Callable[..., R]], Callable[..., R]]\n</code></pre> <pre><code>retry(\n    exceptions: _exceptions = Exception,\n    tries: int = 1,\n    delay: int = 0,\n    print_or_log: Literal[\"print\", \"log\"] = \"print\",\n) -&gt; Callable[[Callable[..., R]], Callable[..., R]]\n</code></pre> <p>Summary</p> <p>Retry a given function a number of times. Catching any known exceptions when they are given. And returning any output to either a terminal or a log file.</p> <p>Deprecated</p> <p>This function is deprecated. Please use the <code>retry()</code> decorator from the <code>stamina</code> package instead. For more info, see: Docs, GitHub, PyPi.</p> Details <p>This function should always be implemented as a decorator. It is written based on the premise that a certain process may fail and return a given message, but that is known and expected, and you just want to wait a second or so then retry again. Typically, this is seen in async processes, or when writing data to a <code>delta</code> table when there may be concurrent read/writes occurring at the same time. In these instances, you will know the error message and can re-try again a certain number of times.</p> <p>Parameters:</p> Name Type Description Default <code>exceptions</code> <code>_exceptions</code> <p>A given single or collection of expected exceptions for which to catch and retry for. Defaults to <code>Exception</code>.</p> <code>Exception</code> <code>tries</code> <code>int</code> <p>The number of retries to attempt. If the underlying process is still failing after this number of attempts, then throw a hard error and alert the user. Defaults to <code>1</code>.</p> <code>1</code> <code>delay</code> <code>int</code> <p>The number of seconds to delay between each retry. Defaults to <code>0</code>.</p> <code>0</code> <code>print_or_log</code> <code>Optional[Literal['print', 'log']]</code> <p>Whether or not the messages should be written to the terminal in a <code>print()</code> statement, or to a log file in a <code>log()</code> statement. Defaults to <code>\"print\"</code>.</p> <code>'print'</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <code>ValueError</code> <p>If either <code>tries</code> or <code>delay</code> are less than <code>0</code></p> <code>RuntimeError</code> <p>If either an unexpected <code>Exception</code> was thrown, which was not declared in the <code>exceptions</code> collection, or if the <code>func</code> was still not able to be executed after <code>tries</code> number of iterations.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>Optional[Any]</code> <p>The result from the underlying function, if any.</p> Examples Imports<pre><code>&gt;&gt;&gt; from toolbox_python.retry import retry\n</code></pre> <p>Example 1: No error<pre><code>&gt;&gt;&gt; @retry(tries=5, delay=1, print_or_log=\"print\")\n&gt;&gt;&gt; def simple_func(var1: str = \"this\") -&gt; str:\n...     return var1\n...\n&gt;&gt;&gt; simple_func()\n</code></pre> Terminal<pre><code># No error\n</code></pre> </p> <p>Example 2: Expected error<pre><code>&gt;&gt;&gt; @retry(exceptions=TypeError, tries=5, delay=1, print_or_log=\"print\")\n&gt;&gt;&gt; def failing_func(var1: str = \"that\") -&gt; None:\n...     raise ValueError(\"Incorrect value\")\n...\n&gt;&gt;&gt; failing_func()\n</code></pre> Terminal<pre><code>Caught an expected error at iteration 1: `ValueError`. Retrying in 1 seconds...\nCaught an expected error at iteration 2: `ValueError`. Retrying in 1 seconds...\nCaught an expected error at iteration 3: `ValueError`. Retrying in 1 seconds...\nCaught an expected error at iteration 4: `ValueError`. Retrying in 1 seconds...\nCaught an expected error at iteration 5: `ValueError`. Retrying in 1 seconds...\nRuntimeError: Still could not write after 5 iterations. Please check.\n</code></pre> </p> Credit <p>Inspiration from:</p> <ul> <li>https://pypi.org/project/retry/</li> <li>https://stackoverflow.com/questions/21786382/pythonic-way-of-retry-running-a-function#answer-21788594</li> </ul> Source code in <code>src/toolbox_python/retry.py</code> <pre><code>@typechecked\ndef retry(\n    exceptions: _exceptions = Exception,\n    tries: int = 1,\n    delay: int = 0,\n    print_or_log: Literal[\"print\", \"log\"] = \"print\",\n) -&gt; Callable[[Callable[..., R]], Callable[..., R]]:\n    \"\"\"\n    !!! note \"Summary\"\n        Retry a given function a number of times. Catching any known exceptions when they are given. And returning any output to either a terminal or a log file.\n\n    !!! deprecation \"Deprecated\"\n        This function is deprecated. Please use the [`retry()`][func] decorator from the [`stamina`][docs] package instead.&lt;br&gt;\n        For more info, see: [Docs][docs], [GitHub][github], [PyPi][pypi].\n        [func]: https://stamina.hynek.me/en/stable/api.html#stamina.retry\n        [docs]: https://stamina.hynek.me/en/stable/index.html\n        [github]: https://github.com/hynek/stamina/\n        [pypi]: https://pypi.org/project/stamina/\n\n    ???+ abstract \"Details\"\n        This function should always be implemented as a decorator.&lt;br&gt;\n        It is written based on the premise that a certain process may fail and return a given message, but that is known and expected, and you just want to wait a second or so then retry again.&lt;br&gt;\n        Typically, this is seen in async processes, or when writing data to a `delta` table when there may be concurrent read/writes occurring at the same time. In these instances, you will know the error message and can re-try again a certain number of times.\n\n    Params:\n        exceptions (_exceptions, optional):\n            A given single or collection of expected exceptions for which to catch and retry for.&lt;br&gt;\n            Defaults to `#!py Exception`.\n        tries (int, optional):\n            The number of retries to attempt. If the underlying process is still failing after this number of attempts, then throw a hard error and alert the user.&lt;br&gt;\n            Defaults to `#!py 1`.\n        delay (int, optional):\n            The number of seconds to delay between each retry.&lt;br&gt;\n            Defaults to `#!py 0`.\n        print_or_log (Optional[Literal[\"print\", \"log\"]], optional):\n            Whether or not the messages should be written to the terminal in a `#!py print()` statement, or to a log file in a `#!py log()` statement.&lt;br&gt;\n            Defaults to `#!py \"print\"`.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n        ValueError:\n            If either `tries` or `delay` are less than `#!py 0`\n        RuntimeError:\n            If _either_ an unexpected `#!py Exception` was thrown, which was not declared in the `exceptions` collection, _or_ if the `func` was still not able to be executed after `tries` number of iterations.\n\n    Returns:\n        result (Optional[Any]):\n            The result from the underlying function, if any.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Imports\"}\n        &gt;&gt;&gt; from toolbox_python.retry import retry\n        ```\n\n        ```{.py .python linenums=\"1\" title=\"Example 1: No error\"}\n        &gt;&gt;&gt; @retry(tries=5, delay=1, print_or_log=\"print\")\n        &gt;&gt;&gt; def simple_func(var1: str = \"this\") -&gt; str:\n        ...     return var1\n        ...\n        &gt;&gt;&gt; simple_func()\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        # No error\n        ```\n        &lt;/div&gt;\n\n        ```{.py .python linenums=\"1\" title=\"Example 2: Expected error\"}\n        &gt;&gt;&gt; @retry(exceptions=TypeError, tries=5, delay=1, print_or_log=\"print\")\n        &gt;&gt;&gt; def failing_func(var1: str = \"that\") -&gt; None:\n        ...     raise ValueError(\"Incorrect value\")\n        ...\n        &gt;&gt;&gt; failing_func()\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        Caught an expected error at iteration 1: `ValueError`. Retrying in 1 seconds...\n        Caught an expected error at iteration 2: `ValueError`. Retrying in 1 seconds...\n        Caught an expected error at iteration 3: `ValueError`. Retrying in 1 seconds...\n        Caught an expected error at iteration 4: `ValueError`. Retrying in 1 seconds...\n        Caught an expected error at iteration 5: `ValueError`. Retrying in 1 seconds...\n        RuntimeError: Still could not write after 5 iterations. Please check.\n        ```\n        &lt;/div&gt;\n\n    ??? success \"Credit\"\n        Inspiration from:\n\n        - https://pypi.org/project/retry/\n        - https://stackoverflow.com/questions/21786382/pythonic-way-of-retry-running-a-function#answer-21788594\n    \"\"\"\n    assert_is_valid(tries, \"&gt;=\", 0)\n    assert_is_valid(delay, \"&gt;=\", 0)\n\n    exceptions = (\n        tuple(exceptions) if isinstance(exceptions, (list, tuple)) else (exceptions,)\n    )\n\n    log: Optional[Logger] = None\n\n    if print_or_log == \"log\":\n        stk: inspect.FrameInfo = inspect.stack()[2]\n        mod: Union[ModuleType, None] = inspect.getmodule(stk[0])\n        if mod is not None:\n            log: Optional[Logger] = logging.getLogger(mod.__name__)\n\n    def decorator(func: Callable):\n        @wraps(func)\n        def result(*args, **kwargs):\n            for i in range(1, tries + 1):\n                try:\n                    results = func(*args, **kwargs)\n                except exceptions as e:\n                    # Catch raw exceptions as defined in the `exceptions` parameter.\n                    message = (\n                        f\"Caught an expected error at iteration {i}: \"\n                        f\"`{get_full_class_name(e)}`. \"\n                        f\"Retrying in {delay} seconds...\"\n                    )\n                    print_or_log_output(\n                        message=message,\n                        print_or_log=print_or_log,\n                        log=log,\n                        log_level=\"warning\",\n                    )\n                    sleep(delay)\n                except Exception as exc:\n                    \"\"\"\n                    Catch unknown exception, however still need to check whether the name of any of the exceptions defined in `exceptions` are somehow listed in the text output of the caught exception.\n                    The cause here is shown in the below chunk. You see here that it throws a 'Py4JJavaError', which was not listed in the `exceptions` parameter, yet within the text output, it showed the 'ConcurrentDeleteReadException' which _was_ listed in the `exceptions` parameter. Therefore, in this instance, we still want to sleep and retry\n\n                    &gt;&gt;&gt; Caught an unexpected error at iteration 1: `py4j.protocol.Py4JJavaError`.\n                    &gt;&gt;&gt; Time for fct_Receipt: 27secs\n                    &gt;&gt;&gt; java.util.concurrent.ExecutionException: io.delta.exceptions.\n                    ...     ConcurrentDeleteReadException: This transaction attempted to read one or more files that were deleted (for example part-00001-563449ea-73e4-4d7d-8ba8-53fee1f8a5ff.c000.snappy.parquet in the root of the table) by a concurrent update. Please try the operation again.\n                    \"\"\"\n                    excs = (\n                        [exceptions]\n                        if not isinstance(exceptions, (list, tuple))\n                        else exceptions\n                    )\n                    exc_names = [exc.__name__ for exc in excs]\n                    if any(name in f\"{exc}\" for name in exc_names):\n                        caught_error = [name for name in exc_names if name in f\"{exc}\"]\n                        message = (\n                            f\"Caught an unexpected, known error at iteration {i}: \"\n                            f\"`{get_full_class_name(exc)}`.\\n\"\n                            f\"Who's message contains reference to underlying exception(s): {caught_error}.\\n\"\n                            f\"Retrying in {delay} seconds...\"\n                        )\n                        print_or_log_output(\n                            message=message,\n                            print_or_log=print_or_log,\n                            log=log,\n                            log_level=\"warning\",\n                        )\n                        sleep(delay)\n                    else:\n                        message = (\n                            f\"Caught an unexpected error at iteration {i}: \"\n                            f\"`{get_full_class_name(exc)}`.\"\n                        )\n                        print_or_log_output(\n                            message=message,\n                            print_or_log=print_or_log,\n                            log=log,\n                            log_level=\"error\",\n                        )\n                        raise RuntimeError(message) from exc\n                else:\n                    message = f\"Successfully executed at iteration {i}.\"\n                    print_or_log_output(\n                        message=message,\n                        print_or_log=print_or_log,\n                        log=log,\n                        log_level=\"info\",\n                    )\n                    return results\n            message = f\"Still could not write after {tries} iterations. Please check.\"\n            print_or_log_output(\n                message=message,\n                print_or_log=print_or_log,\n                log=log,\n                log_level=\"error\",\n            )\n            raise RuntimeError(message)\n\n        return result\n\n    return decorator\n</code></pre>"},{"location":"code/strings/","title":"Strings","text":""},{"location":"code/strings/#toolbox_python.strings","title":"toolbox_python.strings","text":"<p>Summary</p> <p>The <code>strings</code> module is for manipulating and checking certain string objects.</p>"},{"location":"code/strings/#toolbox_python.strings.str_replace","title":"str_replace","text":"<pre><code>str_replace(\n    old_string: str,\n    replace_chars: str = string.punctuation\n    + string.whitespace,\n    replace_with: str = \"\",\n) -&gt; str\n</code></pre> <p>Summary</p> <p>Replace the characters with a given string.</p> Details <p>Similar to the Python <code>str.replace()</code> method, but provides more customisation through the use of the <code>re</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>old_string</code> <code>str</code> <p>The old string to be replaced.</p> required <code>replace_chars</code> <code>str</code> <p>The characters that need replacing. Defaults to <code>string.punctuation + string.whitespace</code>.</p> <code>punctuation + whitespace</code> <code>replace_with</code> <code>str</code> <p>The value to replace the characters with. Defaults to <code>\"\"</code>.</p> <code>''</code> <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>str</code> <p>The new formatted string.</p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.strings import str_replace\n&gt;&gt;&gt; long_string = \"This long string\"\n&gt;&gt;&gt; complex_sentence = \"Because my pizza was cold, I put it in the microwave.\"\n</code></pre> <p>Example 1: Replace all spaces (` `) with underscore (`_`)<pre><code>&gt;&gt;&gt; print(str_replace(long_string, \" \", \"_\"))\n</code></pre> Terminal<pre><code>\"This_long_string\"\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Example 2: Remove all punctuation and white space<pre><code>&gt;&gt;&gt; print(str_replace(complex_sentence))\n</code></pre> Terminal<pre><code>\"BecausemylunchwascoldIputitinthemicrowave\"\n</code></pre> <p>Conclusion: Successful conversion.</p> <p>Example 3: Invalid `old_string` input<pre><code>&gt;&gt;&gt; print(str_replace(123))\n</code></pre> Terminal<pre><code>TypeError: ...\n</code></pre> <p>Conclusion: Invalid input.</p> <p>Note: The same error will occur if <code>replace_chars</code> or <code>replace_with</code> are not of type <code>str</code>.</p> Credit <p>Full credit goes to: https://stackoverflow.com/questions/23996118/replace-special-characters-in-a-string-python#answer-23996414</p> See Also <ul> <li><code>re</code></li> </ul> Source code in <code>src/toolbox_python/strings.py</code> <pre><code>@typechecked\ndef str_replace(\n    old_string: str,\n    replace_chars: str = string.punctuation + string.whitespace,\n    replace_with: str = \"\",\n) -&gt; str:\n    \"\"\"\n    !!! note \"Summary\"\n        Replace the characters with a given string.\n\n    ???+ abstract \"Details\"\n        Similar to the Python `#!py str.replace()` method, but provides more customisation through the use of the [`re`](https://docs.python.org/3/library/re.html) package.\n\n    Params:\n        old_string (str):\n            The old string to be replaced.\n        replace_chars (str, optional):\n            The characters that need replacing.&lt;br&gt;\n            Defaults to `#!py string.punctuation + string.whitespace`.\n        replace_with (str, optional):\n            The value to replace the characters with.&lt;br&gt;\n            Defaults to `\"\"`.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (str):\n            The new formatted string.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.strings import str_replace\n        &gt;&gt;&gt; long_string = \"This long string\"\n        &gt;&gt;&gt; complex_sentence = \"Because my pizza was cold, I put it in the microwave.\"\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Replace all spaces (` `) with underscore (`_`)\"}\n        &gt;&gt;&gt; print(str_replace(long_string, \" \", \"_\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        \"This_long_string\"\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Remove all punctuation and white space\"}\n        &gt;&gt;&gt; print(str_replace(complex_sentence))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        \"BecausemylunchwascoldIputitinthemicrowave\"\n        ```\n        !!! success \"Conclusion: Successful conversion.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Invalid `old_string` input\"}\n        &gt;&gt;&gt; print(str_replace(123))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        TypeError: ...\n        ```\n        !!! failure \"Conclusion: Invalid input.\"\n        !!! observation \"Note: The same error will occur if `replace_chars` or `replace_with` are not of type `str`.\"\n        &lt;/div&gt;\n\n    ??? success \"Credit\"\n        Full credit goes to:&lt;br&gt;\n        https://stackoverflow.com/questions/23996118/replace-special-characters-in-a-string-python#answer-23996414\n\n    ??? tip \"See Also\"\n        - [`re`](https://docs.python.org/3/library/re.html)\n    \"\"\"\n    chars: str = re.escape(replace_chars)\n    return re.sub(rf\"[{chars}]\", replace_with, old_string)\n</code></pre>"},{"location":"code/strings/#toolbox_python.strings.str_contains","title":"str_contains","text":"<pre><code>str_contains(check_string: str, sub_string: str) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check whether one string contains another string.</p> Details <p>This is a super simple one-line function.</p> Example<pre><code>return True if sub_string in check_string else False\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>check_string</code> <code>str</code> <p>The main string to check.</p> required <code>sub_string</code> <code>str</code> <p>The substring to check.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>sub_string</code> in <code>check_string</code></p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.strings import str_contains\n&gt;&gt;&gt; long_string = \"This long string\"\n</code></pre> <p>Example 1: String is contained<pre><code>&gt;&gt;&gt; print(str_contains(long_string, \"long\"))\n</code></pre> Terminal<pre><code>True\n</code></pre> <p>Conclusion: <code>long_string</code> contains <code>\"long\"</code>.</p> <p>Example 2: String is not contained<pre><code>&gt;&gt;&gt; print(str_contains(long_string, \"short\"))\n</code></pre> Terminal<pre><code>False\n</code></pre> <p>Conclusion: <code>long_string</code> does not contain <code>\"short\"</code>.</p> <p>Example 3: Invalid `check_string` input<pre><code>&gt;&gt;&gt; print(str_contains(123, \"short\"))\n</code></pre> Terminal<pre><code>TypeError: ...\n</code></pre> <p>Conclusion: Invalid input.</p> <p>Note: The same error will occur if <code>sub_string</code> is not of type <code>str</code>.</p> See Also <ul> <li><code>str_contains_any()</code></li> <li><code>str_contains_all()</code></li> </ul> Source code in <code>src/toolbox_python/strings.py</code> <pre><code>@typechecked\ndef str_contains(check_string: str, sub_string: str) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check whether one string contains another string.\n\n    ???+ abstract \"Details\"\n        This is a super simple one-line function.\n\n        ```py linenums=\"1\" title=\"Example\"\n        return True if sub_string in check_string else False\n        ```\n\n    Params:\n        check_string (str):\n            The main string to check.\n        sub_string (str):\n            The substring to check.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (bool):\n            `#!py True` if `#!py sub_string` in `#!py check_string`\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.strings import str_contains\n        &gt;&gt;&gt; long_string = \"This long string\"\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: String is contained\"}\n        &gt;&gt;&gt; print(str_contains(long_string, \"long\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        True\n        ```\n        !!! success \"Conclusion: `#!py long_string` contains `#!py \"long\"`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: String is not contained\"}\n        &gt;&gt;&gt; print(str_contains(long_string, \"short\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        False\n        ```\n        !!! success \"Conclusion: `#!py long_string` does not contain `#!py \"short\"`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Invalid `check_string` input\"}\n        &gt;&gt;&gt; print(str_contains(123, \"short\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        TypeError: ...\n        ```\n        !!! failure \"Conclusion: Invalid input.\"\n        !!! observation \"Note: The same error will occur if `sub_string` is not of type `str`.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`str_contains_any()`][toolbox_python.strings.str_contains_any]\n        - [`str_contains_all()`][toolbox_python.strings.str_contains_all]\n    \"\"\"\n    return sub_string in check_string\n</code></pre>"},{"location":"code/strings/#toolbox_python.strings.str_contains_any","title":"str_contains_any","text":"<pre><code>str_contains_any(\n    check_string: str, sub_strings: str_list_tuple\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check whether any one of a number of strings are contained within a main string.</p> <p>Parameters:</p> Name Type Description Default <code>check_string</code> <code>str</code> <p>The main string to check.</p> required <code>sub_strings</code> <code>str_list_tuple</code> <p>The collection of substrings to check.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>any</code> of the strings in <code>sub_strings</code> are contained within <code>check_string</code>.</p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.strings import str_contains_any\n&gt;&gt;&gt; long_string = \"This long string\"\n</code></pre> <p>Example 1: Contains any<pre><code>&gt;&gt;&gt; print(str_contains_any(long_string, [\"long\", \"short\"]))\n</code></pre> Terminal<pre><code>True\n</code></pre> <p>Conclusion: <code>long_string</code> contains either <code>\"long\"</code> or <code>\"short\"</code>.</p> <p>Example 2: Contains none<pre><code>&gt;&gt;&gt; print(str_contains_any(long_string, [\"this\", \"that\"]))\n</code></pre> Terminal<pre><code>False\n</code></pre> <p>Conclusion: <code>long_string</code> contains neither <code>\"this\"</code> nor <code>\"that\"</code>.</p> <p>Example 3: Invalid `check_string` input<pre><code>&gt;&gt;&gt; print(str_contains_any(123, [\"short\", \"long\"]))\n</code></pre> Terminal<pre><code>TypeError: ...\n</code></pre> <p>Conclusion: Invalid input.</p> <p>Note: The same error will occur if any of the elements in <code>sub_strings</code> are not of type <code>str</code>.</p> See Also <ul> <li><code>str_contains()</code></li> <li><code>str_contains_all()</code></li> </ul> Source code in <code>src/toolbox_python/strings.py</code> <pre><code>@typechecked\ndef str_contains_any(\n    check_string: str,\n    sub_strings: str_list_tuple,\n) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check whether any one of a number of strings are contained within a main string.\n\n    Params:\n        check_string (str):\n            The main string to check.\n        sub_strings (str_list_tuple):\n            The collection of substrings to check.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (bool):\n            `#!py True` if `#!py any` of the strings in `#!py sub_strings` are contained within `#!py check_string`.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.strings import str_contains_any\n        &gt;&gt;&gt; long_string = \"This long string\"\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Contains any\"}\n        &gt;&gt;&gt; print(str_contains_any(long_string, [\"long\", \"short\"]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        True\n        ```\n        !!! success \"Conclusion: `#!py long_string` contains either `#!py \"long\"` or `#!py \"short\"`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Contains none\"}\n        &gt;&gt;&gt; print(str_contains_any(long_string, [\"this\", \"that\"]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        False\n        ```\n        !!! success \"Conclusion: `#!py long_string` contains neither `#!py \"this\"` nor `#!py \"that\"`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Invalid `check_string` input\"}\n        &gt;&gt;&gt; print(str_contains_any(123, [\"short\", \"long\"]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        TypeError: ...\n        ```\n        !!! failure \"Conclusion: Invalid input.\"\n        !!! observation \"Note: The same error will occur if any of the elements in `sub_strings` are not of type `str`.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`str_contains()`][toolbox_python.strings.str_contains]\n        - [`str_contains_all()`][toolbox_python.strings.str_contains_all]\n    \"\"\"\n    return any(\n        str_contains(\n            check_string=check_string,\n            sub_string=sub_string,\n        )\n        for sub_string in sub_strings\n    )\n</code></pre>"},{"location":"code/strings/#toolbox_python.strings.str_contains_all","title":"str_contains_all","text":"<pre><code>str_contains_all(\n    check_string: str, sub_strings: str_list_tuple\n) -&gt; bool\n</code></pre> <p>Summary</p> <p>Check to ensure that all sub-strings are contained within a main string.</p> <p>Parameters:</p> Name Type Description Default <code>check_string</code> <code>str</code> <p>The main string to check.</p> required <code>sub_strings</code> <code>str_list_tuple</code> <p>The collection of substrings to check.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>all</code> of the strings in <code>sub_strings</code> are contained within <code>check_string</code>.</p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.strings import str_contains_all\n&gt;&gt;&gt; long_string = \"This long string\"\n</code></pre> <p>Example 1: Contains all<pre><code>&gt;&gt;&gt; print(str_contains_all(long_string, [\"long\", \"string\"]))\n</code></pre> Terminal<pre><code>True\n</code></pre> <p>Conclusion: <code>long_string</code> contains both <code>\"long\"</code> and <code>\"string\"</code>.</p> <p>Example 2: Contains some<pre><code>&gt;&gt;&gt; print(str_contains_all(long_string, [\"long\", \"something\"]))\n</code></pre> Terminal<pre><code>False\n</code></pre> <p>Conclusion: <code>long_string</code> contains <code>\"long\"</code> but not <code>\"something\"</code>.</p> <p>Example 3: Contains none<pre><code>&gt;&gt;&gt; print(str_contains_all(long_string, [\"this\", \"that\"]))\n</code></pre> Terminal<pre><code>False\n</code></pre> <p>Conclusion: <code>long_string</code> contains neither <code>\"this\"</code> nor <code>\"that\"</code>.</p> <p>Example 4: Invalid `check_string` input<pre><code>&gt;&gt;&gt; print(str_contains_all(123, [\"short\", \"long\"]))\n</code></pre> Terminal<pre><code>TypeError: ...\n</code></pre> <p>Conclusion: Invalid input.</p> <p>Note: The same error will occur if any of the elements in <code>sub_strings</code> are not of type <code>str</code>.</p> See Also <ul> <li><code>str_contains()</code></li> <li><code>str_contains_any()</code></li> </ul> Source code in <code>src/toolbox_python/strings.py</code> <pre><code>@typechecked\ndef str_contains_all(\n    check_string: str,\n    sub_strings: str_list_tuple,\n) -&gt; bool:\n    \"\"\"\n    !!! note \"Summary\"\n        Check to ensure that all sub-strings are contained within a main string.\n\n    Params:\n        check_string (str):\n            The main string to check.\n        sub_strings (str_list_tuple):\n            The collection of substrings to check.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (bool):\n            `#!py True` if `#!py all` of the strings in `#!py sub_strings` are contained within `#!py check_string`.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.strings import str_contains_all\n        &gt;&gt;&gt; long_string = \"This long string\"\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Contains all\"}\n        &gt;&gt;&gt; print(str_contains_all(long_string, [\"long\", \"string\"]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        True\n        ```\n        !!! success \"Conclusion: `#!py long_string` contains both `#!py \"long\"` and `#!py \"string\"`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Contains some\"}\n        &gt;&gt;&gt; print(str_contains_all(long_string, [\"long\", \"something\"]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        False\n        ```\n        !!! failure \"Conclusion: `#!py long_string` contains `#!py \"long\"` but not `#!py \"something\"`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: Contains none\"}\n        &gt;&gt;&gt; print(str_contains_all(long_string, [\"this\", \"that\"]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        False\n        ```\n        !!! failure \"Conclusion: `#!py long_string` contains neither `#!py \"this\"` nor `#!py \"that\"`.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Invalid `check_string` input\"}\n        &gt;&gt;&gt; print(str_contains_all(123, [\"short\", \"long\"]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        TypeError: ...\n        ```\n        !!! failure \"Conclusion: Invalid input.\"\n        !!! observation \"Note: The same error will occur if any of the elements in `sub_strings` are not of type `str`.\"\n        &lt;/div&gt;\n\n    ??? tip \"See Also\"\n        - [`str_contains()`][toolbox_python.strings.str_contains]\n        - [`str_contains_any()`][toolbox_python.strings.str_contains_any]\n    \"\"\"\n    return all(\n        str_contains(\n            check_string=check_string,\n            sub_string=sub_string,\n        )\n        for sub_string in sub_strings\n    )\n</code></pre>"},{"location":"code/strings/#toolbox_python.strings.str_separate_number_chars","title":"str_separate_number_chars","text":"<pre><code>str_separate_number_chars(text: str) -&gt; str_list\n</code></pre> <p>Summary</p> <p>Take in a string that contains both numbers and letters, and output a list of strings, separated to have each element containing either entirely number or entirely letters.</p> Details <p>Uses regex (<code>re.split()</code>) to perform the actual splitting. Note, it will preserve special characters &amp; punctuation, but it will not preserve whitespaces.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The string to split.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If any of the inputs parsed to the parameters of this function are not the correct type. Uses the <code>@typeguard.typechecked</code> decorator.</p> <p>Returns:</p> Type Description <code>str_list</code> <p>The updated list, with each element of the list containing either entirely characters or entirely numbers.</p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.strings import str_contains_all\n&gt;&gt;&gt; simple_string = \"-12.1grams\"\n&gt;&gt;&gt; complex_string = \"abcd2343 abw34324 abc3243-23A 123\"\n</code></pre> <p>Example 1: Simple split<pre><code>&gt;&gt;&gt; print(str_separate_number_chars(simple_string))\n</code></pre> Terminal<pre><code>[\"-12.1\", \"grams\"]\n</code></pre> <p>Conclusion: Successful split.</p> <p>Example 2: Complex split<pre><code>&gt;&gt;&gt; print(str_separate_number_chars(complex_string))\n</code></pre> Terminal<pre><code>[\n    \"abcd\",\n    \"2343\",\n    \"abw\",\n    \"34324\",\n    \"abc\",\n    \"3243\",\n    \"-23\",\n    \"A\",\n    \"123\",\n]\n</code></pre> <p>Conclusion: Successful split.</p> <p>Example 3: `text` does not contain any numbers<pre><code>&gt;&gt;&gt; print(str_separate_number_chars(\"abcd\"))\n</code></pre> Terminal<pre><code>[\"abcd\"]\n</code></pre> <p>Conclusion: No numbers in <code>text</code>, so returns a single-element long list.</p> <p>Example 4: Invalid `text` input<pre><code>&gt;&gt;&gt; print(str_separate_number_chars(123))\n</code></pre> Terminal<pre><code>TypeError: ...\n</code></pre> <p>Conclusion: Invalid input.</p> Credit <p>Full credit goes to: https://stackoverflow.com/questions/3340081/product-code-looks-like-abcd2343-how-to-split-by-letters-and-numbers#answer-63362709.</p> See Also <ul> <li><code>re</code></li> </ul> Source code in <code>src/toolbox_python/strings.py</code> <pre><code>@typechecked\ndef str_separate_number_chars(text: str) -&gt; str_list:\n    \"\"\"\n    !!! note \"Summary\"\n        Take in a string that contains both numbers and letters, and output a list of strings, separated to have each element containing either entirely number or entirely letters.\n\n    ???+ abstract \"Details\"\n        Uses regex ([`re.split()`](https://docs.python.org/3/library/re.html#re.split)) to perform the actual splitting.&lt;br&gt;\n        Note, it _will_ preserve special characters &amp; punctuation, but it _will not_ preserve whitespaces.\n\n    Params:\n        text (str):\n            The string to split.\n\n    Raises:\n        TypeCheckError:\n            If any of the inputs parsed to the parameters of this function are not the correct type. Uses the [`@typeguard.typechecked`](https://typeguard.readthedocs.io/en/stable/api.html#typeguard.typechecked) decorator.\n\n    Returns:\n        (str_list):\n            The updated list, with each element of the list containing either entirely characters or entirely numbers.\n\n    ???+ example \"Examples\"\n\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.strings import str_contains_all\n        &gt;&gt;&gt; simple_string = \"-12.1grams\"\n        &gt;&gt;&gt; complex_string = \"abcd2343 abw34324 abc3243-23A 123\"\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Simple split\"}\n        &gt;&gt;&gt; print(str_separate_number_chars(simple_string))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [\"-12.1\", \"grams\"]\n        ```\n        !!! success \"Conclusion: Successful split.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Complex split\"}\n        &gt;&gt;&gt; print(str_separate_number_chars(complex_string))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [\n            \"abcd\",\n            \"2343\",\n            \"abw\",\n            \"34324\",\n            \"abc\",\n            \"3243\",\n            \"-23\",\n            \"A\",\n            \"123\",\n        ]\n        ```\n        !!! success \"Conclusion: Successful split.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 3: `text` does not contain any numbers\"}\n        &gt;&gt;&gt; print(str_separate_number_chars(\"abcd\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [\"abcd\"]\n        ```\n        !!! success \"Conclusion: No numbers in `#!py text`, so returns a single-element long list.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 4: Invalid `text` input\"}\n        &gt;&gt;&gt; print(str_separate_number_chars(123))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        TypeError: ...\n        ```\n        !!! failure \"Conclusion: Invalid input.\"\n        &lt;/div&gt;\n\n    ??? success \"Credit\"\n        Full credit goes to:&lt;br&gt;\n        https://stackoverflow.com/questions/3340081/product-code-looks-like-abcd2343-how-to-split-by-letters-and-numbers#answer-63362709.\n\n    ??? tip \"See Also\"\n        - [`re`](https://docs.python.org/3/library/re.html)\n    \"\"\"\n    res = re.split(r\"([-+]?\\d+\\.\\d+)|([-+]?\\d+)\", text.strip())\n    return [r.strip() for r in res if r is not None and r.strip() != \"\"]\n</code></pre>"},{"location":"code/strings/#toolbox_python.strings.str_to_list","title":"str_to_list","text":"<pre><code>str_to_list(obj: str) -&gt; str_list\n</code></pre><pre><code>str_to_list(obj: Any) -&gt; Any\n</code></pre> <pre><code>str_to_list(obj: Any) -&gt; Union[str_list, Any]\n</code></pre> <p>Summary</p> <p>Convert a string to a list containing that string as the only element.</p> Details <p>This function is useful when you want to ensure that a string is treated as a list, even if it is a single string. If the input is already a list, it will return it unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to convert to a list if it is a string.</p> required <p>Raises:</p> Type Description <code>TypeCheckError</code> <p>If <code>obj</code> is not a string or a list.</p> <p>Returns:</p> Type Description <code>Union[str_list, Any]</code> <p>If <code>obj</code> is a string, returns a list containing that string as the only element. If <code>obj</code> is not a string, returns it unchanged.</p> Examples Set up<pre><code>&gt;&gt;&gt; from toolbox_python.strings import str_to_list\n</code></pre> <p>Example 1: Convert string to list<pre><code>&gt;&gt;&gt; print(str_to_list(\"hello\"))\n</code></pre> Terminal<pre><code>[\"hello\"]\n</code></pre> <p>Conclusion: Successfully converted string to list.</p> <p>Example 2: Input is already a list<pre><code>&gt;&gt;&gt; print(str_to_list([\"hello\", \"world\"]))\n</code></pre> Terminal<pre><code>[\"hello\", \"world\"]\n</code></pre> <p>Conclusion: Input was already a list, so returned unchanged.</p> Source code in <code>src/toolbox_python/strings.py</code> <pre><code>@typechecked\ndef str_to_list(obj: Any) -&gt; Union[str_list, Any]:\n    \"\"\"\n    !!! note \"Summary\"\n        Convert a string to a list containing that string as the only element.\n\n    ???+ abstract \"Details\"\n        This function is useful when you want to ensure that a string is treated as a list, even if it is a single string. If the input is already a list, it will return it unchanged.\n\n    Params:\n        obj (Any):\n            The object to convert to a list if it is a string.\n\n    Raises:\n        TypeCheckError:\n            If `obj` is not a string or a list.\n\n    Returns:\n        (Union[str_list, Any]):\n            If `obj` is a string, returns a list containing that string as the only element. If `obj` is not a string, returns it unchanged.\n\n    ???+ example \"Examples\"\n        ```pycon {.py .python linenums=\"1\" title=\"Set up\"}\n        &gt;&gt;&gt; from toolbox_python.strings import str_to_list\n        ```\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 1: Convert string to list\"}\n        &gt;&gt;&gt; print(str_to_list(\"hello\"))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [\"hello\"]\n        ```\n        !!! success \"Conclusion: Successfully converted string to list.\"\n        &lt;/div&gt;\n\n        ```pycon {.py .python linenums=\"1\" title=\"Example 2: Input is already a list\"}\n        &gt;&gt;&gt; print(str_to_list([\"hello\", \"world\"]))\n        ```\n        &lt;div class=\"result\" markdown&gt;\n        ```{.sh .shell title=\"Terminal\"}\n        [\"hello\", \"world\"]\n        ```\n        !!! success \"Conclusion: Input was already a list, so returned unchanged.\"\n        &lt;/div&gt;\n    \"\"\"\n    return [obj] if is_type(obj, str) else obj\n</code></pre>"},{"location":"usage/changelog/","title":"Change Log","text":"<p>v1.4.1</p> <p>v1.4.0</p> <p>v1.3.2</p> <p>v1.3.1</p> <p>v1.2.1</p> <p>v1.2.0</p> <p>v1.1.0</p> <p>v1.0.4</p> <p>v1.0.3</p> <p>v1.0.2</p> <p>v1.0.1</p> <p>v1.0.0</p> <p>v0.10.3</p> <p>v0.10.2</p> <p>v0.10.1</p> <p>v0.9.1</p> <p>v0.8.1</p> <p>v0.7.1</p> <p>v0.6.1</p> <p>v0.5.1</p> <p>v0.4.1</p> <p>v0.3.1</p> <p>v0.2.1</p> <p>v0.1.1</p>"},{"location":"usage/changelog/#v141-documentation-infrastructure-enhancement-and-automated-changelog-generation","title":"v1.4.1 - Documentation Infrastructure Enhancement and Automated Changelog Generation","text":"<p><code>v1.4.1</code> <code>2025-08-03</code> data-science-extensions/toolbox-python/releases/v1.4.1</p> Release Notes Updates <ul> <li> <p>Refactor release notes and commit message formatting for improved readability and maintainability (by chrimaho) View</p> </li> <li> <p>Add environment variable checks for <code>GITHUB_TOKEN</code> and <code>REPOSITORY_NAME</code> (by chrimaho) View</p> </li> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Fix formatting in the <code>shortcodes</code> module (by chrimaho) View</p> </li> <li> <p>Add first draft of <code>CHANGELOG.md</code> (by chrimaho) View</p> </li> <li> <p>Add <code>Contribution Guidelines</code> page (by chrimaho) View</p> </li> <li> <p>Add process for generating changelog during CD pipeline (by chrimaho) View</p> </li> <li> <p>Add process for generating shortcodes in docs (by chrimaho) View</p> </li> <li> <p>Initial commit of the <code>CONTRIBUTING</code> docs (by chrimaho) View</p> </li> <li> <p>Hide the lines in the CD workflow which are causing issues (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#summary","title":"\ud83d\udccb Summary","text":"<p>Version 1.4.1 focuses on enhancing the project's documentation infrastructure and establishing automated changelog generation capabilities. This release introduces comprehensive contribution guidelines, automated changelog workflows, and improved documentation styling to streamline the development process and enhance the contributor experience.</p>"},{"location":"usage/changelog/#automated-changelog-system","title":"\ud83d\udd04 Automated Changelog System","text":"<ul> <li>CI/CD Integration: Automated changelog generation integrated into the continuous deployment pipeline using GitHub Actions</li> <li>Environment Variables: Added support for <code>GITHUB_TOKEN</code> and <code>REPOSITORY_NAME</code> environment variables for secure API access</li> <li>CLI Command: Introduced <code>generate-changelog</code> command for manual changelog creation and debugging purposes</li> <li>Version Control: Automatic commit of changelog updates with version-specific commit messages and skip CI flags</li> </ul>"},{"location":"usage/changelog/#contribution-framework","title":"\ud83d\udcda Contribution Framework","text":"<ul> <li>Guidelines Documentation: Created comprehensive <code>CONTRIBUTING.md</code> with detailed procedures for issue reporting, branch management, coding standards, and review processes</li> <li>Documentation Integration: Added contribution guidelines to the documentation site at <code>docs/usage/contributing.md</code> for improved discoverability</li> <li>Developer Onboarding: Established clear expectations and workflows to reduce contributor onboarding time</li> </ul>"},{"location":"usage/changelog/#documentation-site-enhancements","title":"\ud83d\udcc1 Documentation Site Enhancements","text":""},{"location":"usage/changelog/#visual-improvements","title":"\ud83c\udfa8 Visual Improvements","text":"<ul> <li>Custom Styling: Implemented shortcode CSS system with badge support for enhanced visual consistency across documentation</li> <li>Navigation Structure: Improved site navigation with better organisation and user experience</li> <li>MkDocs Configuration: Enhanced site configuration with updated plugin management and table of contents depth limiting</li> </ul>"},{"location":"usage/changelog/#content-organisation","title":"\ud83d\udcd6 Content Organisation","text":"<ul> <li>Changelog Integration: Added dedicated changelog page (<code>docs/usage/changelog.md</code>) within the documentation site</li> <li>Reference Architecture: Established standardised documentation structure for consistency across all pages</li> </ul>"},{"location":"usage/changelog/#technical-implementation","title":"\ud83e\uddd0 Technical Implementation","text":""},{"location":"usage/changelog/#workflow-automation","title":"\ud83d\udd27 Workflow Automation","text":"<ul> <li>Release Process: Enhanced <code>cd.yml</code> workflow with automated changelog generation steps</li> <li>Error Handling: Improved workflow reliability with proper dependency management and error handling</li> <li>Version Management: Automated tracking and updating of version information throughout the release process</li> </ul>"},{"location":"usage/changelog/#package-configuration","title":"\ud83d\udce6 Package Configuration","text":"<ul> <li>CLI Scripts: Updated <code>pyproject.toml</code> with new CLI commands for changelog generation</li> <li>Build System: Maintained compatibility with existing build processes whilst adding new automation capabilities</li> </ul>"},{"location":"usage/changelog/#code-quality-infrastructure","title":"\ud83d\udd0d Code Quality &amp; Infrastructure","text":""},{"location":"usage/changelog/#maintenance-scripts","title":"\ud83e\uddea Maintenance Scripts","text":"<ul> <li>Changelog Utilities: Enhanced <code>src/utils/changelog.py</code> with improved formatting, error handling, and environment variable support</li> <li>Release Automation: Streamlined release note generation with better readability and maintainability</li> <li>Git Integration: Improved git history processing for structured changelog creation</li> </ul>"},{"location":"usage/changelog/#documentation-standards","title":"\ud83d\udcca Documentation Standards","text":"<ul> <li>Formatting Consistency: Standardised formatting across all documentation files for improved readability</li> <li>Content Structure: Established clear patterns for documentation organisation and presentation</li> </ul>"},{"location":"usage/changelog/#developer-experience-improvements","title":"\ud83d\udcc8 Developer Experience Improvements","text":""},{"location":"usage/changelog/#contributor-benefits","title":"\ud83e\udd1d Contributor Benefits","text":"<ul> <li>Clear Guidelines: Comprehensive contribution documentation reduces confusion and speeds up onboarding</li> <li>Automated Workflows: Changelog generation eliminates manual documentation overhead for maintainers</li> <li>Consistent Standards: Established coding and documentation standards improve code quality and review efficiency</li> </ul>"},{"location":"usage/changelog/#maintainer-benefits","title":"\ud83d\udd27 Maintainer Benefits","text":"<ul> <li>Reduced Manual Work: Automated changelog generation significantly reduces maintenance overhead</li> <li>Quality Assurance: Clear contribution guidelines ensure consistent quality across contributions</li> <li>Streamlined Processes: Automated workflows improve release reliability and reduce human error</li> </ul>"},{"location":"usage/changelog/#infrastructure-foundation","title":"\ud83c\udfd7\ufe0f Infrastructure Foundation","text":"<p>This release establishes a robust foundation for project documentation and automation. The automated changelog system ensures accurate version history tracking, whilst the comprehensive contribution guidelines provide clear expectations for all project participants.</p> <p>The enhanced documentation infrastructure supports better collaboration and reduces the barrier to entry for new contributors, fostering a more inclusive and efficient development environment.</p>"},{"location":"usage/changelog/#whats-changed","title":"\ud83d\udcaa What's Changed","text":"<ul> <li>Documentation Infrastructure Enhancement and Automated Changelog Generation by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/37</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.4.0...v1.4.1</p>"},{"location":"usage/changelog/#v140-comprehensive-package-enhancement-and-tooling-migration","title":"v1.4.0 - Comprehensive Package Enhancement and Tooling Migration","text":"<p><code>v1.4.0</code> <code>2025-07-13</code> data-science-extensions/toolbox-python/releases/v1.4.0</p> Release Notes Updates <ul> <li> <p>Fix echo command to use -E flag for proper interpretation of escape sequences (by chrimaho) View</p> </li> <li> <p>Temporarily turn off pypi deployment step (by chrimaho) View</p> </li> <li> <p>Refactor versioning commands to accept version as an argument and update related CLI functions (by chrimaho) View</p> </li> <li> <p>Fix bug in the CD debugging job     In the CD workflow, when it will throw an error for the <code>github.event.release.name</code> and <code>github.event.release.body</code> when they contain code which is surrounded by the back-tick: <code>&lt;br&gt;     This is because the</code>echo` will escape the back-tick and try to execute the inner text as a command.     This is undesirable behaviour. (by chrimaho) View</p> </li> <li> <p>Fix version bump command and improve regex pattern matching to ensure correct and accurate execution (by chrimaho) View</p> </li> <li> <p>Refactor <code>git</code> command executions to improve reliability, expandability and readability (by chrimaho) View</p> </li> <li> <p>Fix bug in the <code>scripts.git_add_coverage_report()</code> function (by chrimaho) View</p> </li> <li> <p>Fix typo in <code>generators</code> module     Co-authored-by: Copilot 175728472+Copilot@users.noreply.github.com (by chrimaho) View</p> </li> <li> <p>Fix typo in <code>retry</code> module     Co-authored-by: Copilot 175728472+Copilot@users.noreply.github.com (by chrimaho) View</p> </li> <li> <p>Refactor test files to replace any <code>import pytest</code> with <code>from pytest import ...</code> for improved consistency (by chrimaho) View</p> </li> <li> <p>Add input validation for retry parameters using <code>assert_is_valid</code> (by chrimaho) View</p> </li> <li> <p>Refactor CD workflow to replace all 'make' commands with 'uv run' commands for improved consistency and performance (by chrimaho) View</p> </li> <li> <p>Reorganise the <code>[project.scripts]</code> table</p> <ul> <li>Change from <code>cli.scripts:...</code> to <code>utils:scripts:...</code></li> <li>Reorder in to sections: <code>Syncing</code>, <code>Linting</code>, <code>Checking</code></li> <li>Add new sections: <code>Git</code>, <code>Docs</code> (by chrimaho) View</li> </ul> </li> <li> <p>Move <code>scripts.py</code> from<code>src/cli</code> to <code>src/utils</code> and add functions to handle <code>git</code> and <code>docs</code> processes (by chrimaho) View</p> </li> <li> <p>Update <code>bump_version</code> util to be better compatable with CLI execution (by chrimaho) View</p> </li> <li> <p>Add <code>git_checks.sh</code> script to capture git logs and diffs (by chrimaho) View</p> </li> <li> <p>Refactor CI and CD workflows to replace 'make' commands with 'uv' commands for installations and checks (by chrimaho) View</p> </li> <li> <p>Add a more robust way of capturing errors when checking docstrings (by chrimaho) View</p> </li> <li> <p>Fix typos in all docstrings     -&gt; From <code>!!! summary \"Summary\"</code>     -&gt; To <code>!!! note \"Summary\"</code> (by chrimaho) View</p> </li> <li> <p>Add functions to check docstrings in all Python files and in a specific directory (by chrimaho) View</p> </li> <li> <p>Refactor command execution to support space expansion and simplify command syntax (by chrimaho) View</p> </li> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Add project scripts and update build system dependencies (by chrimaho) View</p> </li> <li> <p>Add comprehensive docstring validation system</p> <ul> <li>Implements automated docstring checking with strict formatting requirements including mandatory Summary, Params, Returns/Yields, and Examples sections.</li> <li>Add custom <code>pre-commit</code> hook integration for continuous validation during development workflow.</li> <li>Update existing docstrings to comply with new validation standards and fixes inconsistent section formatting across multiple modules. (by chrimaho) View</li> </ul> </li> <li> <p>Fix error with repo icon in docs page (by chrimaho) View</p> </li> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Improve <code>checkers</code> module documentation and formatting (by chrimaho) View</p> </li> <li> <p>Add new <code>generators</code> module for on-demand data generation</p> <ul> <li>Introduces a new generators module that provides functions for computing data on-the-fly based on input parameters rather than storing it in databases or files.</li> <li>Includes new <code>generate_group_cutoffs()</code> function that divides a total number of items into specified groups, returning start and end indices for each group with proper validation and error handling.</li> <li>Updates documentation to include the new module in the main index with comprehensive description and examples. (by chrimaho) View</li> </ul> </li> <li> <p>Refactors exception handling for the <code>retry()</code> function and add logging initialization</p> <ul> <li>Normalizes exceptions parameter to always be a tuple for consistent handling regardless of input type.</li> <li>Moves log variable initialization outside conditional block to improve code clarity and ensure proper variable scope. (by chrimaho) View</li> </ul> </li> <li> <p>Add validation to the <code>list_columns()</code> function and improve code structure with better comments</p> <ul> <li>Enhances function robustness by adding comprehensive parameter validation using assertion functions to ensure type safety and value constraints.</li> <li>Improves code readability through better organization with descriptive comments that clearly separate validation, preparation, processing, and output phases.</li> <li>Simplifies column width logic by replacing conditional assignment with <code>min()</code> function for cleaner code. (by chrimaho) View</li> </ul> </li> <li> <p>Add new <code>str_to_list()</code> function with overloads and corresponding tests</p> <ul> <li>Introduces a new utility function that converts strings to single-element lists while preserving other data types unchanged.</li> <li>This enhancement provides a convenient way to normalize string inputs for functions that expect list-like objects, improving code flexibility when handling mixed input types.</li> <li>Includes comprehensive test coverage with parameterized tests for various input scenarios including strings, lists, tuples, sets, dictionaries, and numeric types. (by chrimaho) View</li> </ul> </li> <li> <p>Add additional <code>@overload</code>'s for <code>list_columns</code> and <code>retry</code> functions to better enhance type hints in the <code>output</code> and <code>retry</code> modules (by chrimaho) View</p> </li> <li> <p>Update <code>pre-commit</code> hooks versions and remove outdated poetry check (by chrimaho) View</p> </li> <li> <p>Update all code docstrings examples to use <code>pycon</code> syntax for better clarity, and refine the <code>Raises</code> statements (by chrimaho) View</p> </li> <li> <p>Significant improvements to the <code>checkers</code> module</p> <ul> <li>Added <code>OPERATORS</code> constant dictionary to define comparison operations.</li> <li>Introduced <code>is_valid_value</code> and <code>assert_is_valid_value</code> functions for value validation based on operators.</li> <li>Updated documentation in <code>checkers.md</code> to include new functions and constants.</li> <li>Enhanced test coverage in <code>test_checkers.py</code> for the new validation functions.</li> <li>Improved docstrings across all functions (by chrimaho) View</li> </ul> </li> </ul>"},{"location":"usage/changelog/#overview","title":"\ud83d\udccb Overview","text":"<p>This release introduces significant enhancements to the <code>toolbox-python</code> package, including a new <code>generators</code> module, expanded validation capabilities, comprehensive docstring standards, and modernized CI/CD workflows. The changes span 30 commits across multiple areas of the codebase to improve functionality, maintainability, and developer experience while maintaining full backward compatibility.</p>"},{"location":"usage/changelog/#new-modules-and-core-functionality","title":"\ud83c\udd95 New Modules and Core Functionality","text":""},{"location":"usage/changelog/#generators-module","title":"Generators Module","text":"<ul> <li>New module: <code>toolbox_python.generators</code> - Provides functions for computing data on-the-fly based on input parameters rather than storing it in databases or files</li> <li>New function: <code>generate_group_cutoffs()</code> - Divides a total number of items into specified groups, returning start and end indices for each group with proper validation and error handling</li> <li>Documentation: Added comprehensive documentation with examples and complete test coverage</li> </ul>"},{"location":"usage/changelog/#enhanced-checkers-module","title":"Enhanced Checkers Module","text":"<ul> <li>New constant: <code>OPERATORS</code> dictionary - Defines comparison operations for value validation including <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>in</code>, and <code>not in</code></li> <li>New function: <code>is_valid_value()</code> - Checks if a value is valid based on a specified operator and target value</li> <li>New function: <code>assert_is_valid_value()</code> - Assert version of the validation function with proper error handling</li> <li>Enhanced aliases: Added <code>is_valid</code> and <code>assert_is_valid</code> function aliases for consistency and convenience</li> </ul>"},{"location":"usage/changelog/#enhanced-strings-module","title":"Enhanced Strings Module","text":"<ul> <li>New function: <code>str_to_list()</code> - Converts strings to single-element lists while preserving other data types unchanged</li> <li>Type safety: Includes comprehensive overloads and type hints for better development experience</li> <li>Input flexibility: Provides a convenient way to normalize string inputs for functions that expect list-like objects</li> </ul>"},{"location":"usage/changelog/#function-enhancements-and-type-safety","title":"\ud83d\udd27 Function Enhancements and Type Safety","text":""},{"location":"usage/changelog/#improved-type-hints-and-overloads","title":"Improved Type Hints and Overloads","text":"<ul> <li>Enhanced overloads: Added <code>@overload</code> decorators for better type hints in:</li> <li><code>toolbox_python.checkers.is_value_of_type()</code> - Now properly handles both single types and tuple of types</li> <li><code>toolbox_python.output.list_columns()</code> - Distinguishes between print and return modes</li> <li><code>toolbox_python.retry.retry()</code> - Better handling of different parameter combinations</li> <li>Type validation: Enhanced parameter validation across multiple functions using new assertion functions</li> </ul>"},{"location":"usage/changelog/#function-robustness-improvements","title":"Function Robustness Improvements","text":"<ul> <li>Parameter validation: Added comprehensive input validation using <code>assert_is_valid</code> functions to ensure type safety and value constraints</li> <li>Error handling: Improved exception handling for the <code>retry()</code> function with better logging initialization and normalized exception parameter handling</li> <li>Code structure: Better organization with descriptive comments separating validation, preparation, processing, and output phases</li> <li>Column width logic: Simplified logic in <code>list_columns()</code> by replacing conditional assignment with <code>min()</code> function for cleaner code</li> </ul>"},{"location":"usage/changelog/#package-scripts-and-automation","title":"\ud83d\udcdc Package Scripts and Automation","text":""},{"location":"usage/changelog/#comprehensive-utility-scripts","title":"Comprehensive Utility Scripts","text":"<ul> <li>Script module: <code>src/utils/scripts.py</code> - Extensive collection of utility functions organized into categories:</li> <li>Syncing: <code>uv_sync()</code> for dependency management</li> <li>Linting: <code>run_black()</code>, <code>run_isort()</code>, <code>run_pycln()</code>, <code>run_pyupgrade()</code>, <code>run_blacken_docs()</code>, and combined <code>lint()</code></li> <li>Checking: <code>check_black()</code>, <code>check_mypy()</code>, <code>check_pytest()</code>, <code>check_codespell()</code>, <code>check_pylint()</code>, and comprehensive <code>check()</code></li> <li>Git operations: <code>add_git_credentials()</code>, <code>git_refresh_current_branch()</code>, <code>git_switch_to_main_branch()</code>, <code>git_add_coverage_report()</code></li> <li>Documentation: <code>docs_build_static()</code>, <code>docs_serve_versioned()</code>, <code>build_versioned_docs()</code>, and version management</li> </ul>"},{"location":"usage/changelog/#project-scripts-configuration","title":"Project Scripts Configuration","text":"<ul> <li>Package scripts: Added extensive <code>[project.scripts]</code> table in <code>pyproject.toml</code> with organized sections:</li> <li>Syncing: <code>sync</code></li> <li>Linting: <code>run-black</code>, <code>run-isort</code>, <code>lint</code>, <code>lint-check</code></li> <li>Checking: <code>check-black</code>, <code>check-mypy</code>, <code>check-pytest</code>, <code>check-docstrings</code>, <code>check</code></li> <li>Git: <code>add-git-credentials</code>, <code>git-switch-to-main-branch</code>, <code>bump-version</code>, <code>git-update-version</code></li> <li>Docs: <code>docs-serve-static</code>, <code>build-versioned-docs</code>, <code>docs-check-versions</code></li> <li>Enhanced version management: Updated <code>src/utils/bump_version.py</code> for better CLI compatibility and version tracking</li> </ul>"},{"location":"usage/changelog/#docstring-standards-and-validation","title":"\ud83d\udcda Docstring Standards and Validation","text":""},{"location":"usage/changelog/#automated-docstring-validation-system","title":"Automated Docstring Validation System","text":"<ul> <li>Validation infrastructure: Implemented comprehensive docstring checking with strict formatting requirements:</li> <li><code>FunctionAndClassDetails()</code> - Named tuple for tracking function and class details</li> <li><code>check_docstrings_file()</code> - Validates docstrings in individual files with detailed error reporting</li> <li><code>_check_single_docstring()</code> - Validates individual function/class docstrings against standards</li> <li><code>_check_section_order()</code> - Ensures proper section ordering (Summary \u2192 Params \u2192 Returns/Yields \u2192 Examples)</li> <li><code>_validate_section_formats()</code> - Validates specific section formats and content structure</li> <li><code>check_docstrings_cli()</code>, <code>check_docstrings_all()</code>, <code>check_docstrings_dir()</code> - Various checking interfaces</li> </ul>"},{"location":"usage/changelog/#enhanced-docstring-standards","title":"Enhanced Docstring Standards","text":"<ul> <li>Mandatory sections: Summary, Params, Returns/Yields, and Examples sections now required for all functions and classes</li> <li>Format consistency: Fixed typos across all docstrings from <code>!!! summary \"Summary\"</code> to <code>!!! note \"Summary\"</code></li> <li>Examples improvements: Updated all code examples to use <code>pycon</code> syntax for better clarity and consistency</li> <li>Type information: Enhanced <code>Raises</code> statements with proper exception types (e.g., <code>TypeError</code>, <code>ValueError</code>, <code>LookupError</code>) and detailed descriptions</li> <li>Documentation quality: Improved parameter descriptions, return value specifications, and comprehensive usage examples</li> </ul>"},{"location":"usage/changelog/#cicd-workflow-modernization","title":"\ud83d\ude80 CI/CD Workflow Modernization","text":""},{"location":"usage/changelog/#migration-to-uv-based-tooling","title":"Migration to UV-Based Tooling","text":"<ul> <li>CI workflow: Complete refactoring of <code>.github/workflows/ci.yml</code>:</li> <li>Replaced all <code>make</code> commands with <code>uv run</code> commands for improved consistency and performance</li> <li>Added UV environment variables for optimal configuration</li> <li>Streamlined dependency installation and checking processes</li> <li>CD workflow: Comprehensive modernization of <code>.github/workflows/cd.yml</code>:</li> <li>Replaced <code>make</code> commands with <code>uv run</code> commands throughout all jobs</li> <li>Added environment variables for UV configuration (<code>UV_LINK_MODE</code>, <code>UV_NATIVE_TLS</code>, <code>UV_NO_SYNC</code>)</li> <li>Improved git operations with new utility functions</li> <li>Enhanced version management and tag handling</li> <li>Fixed tag reference issues to ensure correct version numbers in releases</li> <li>Streamlined package building and publishing processes</li> </ul>"},{"location":"usage/changelog/#enhanced-pre-commit-integration","title":"Enhanced Pre-commit Integration","text":"<ul> <li>Hook updates: Updated pre-commit hook versions for better compatibility:</li> <li>Updated <code>mypy</code> from v1.15.0 to v1.16.1 with additional <code>--allow-redefinition</code> flag</li> <li>Updated <code>pyupgrade</code> from v3.19.1 to v3.20.0</li> <li>Updated <code>uv-pre-commit</code> from 0.6.12 to 0.7.20</li> <li>Removed outdated poetry check hooks</li> <li>New validation: Added <code>check-docstrings</code> hook for continuous validation during development workflow</li> </ul>"},{"location":"usage/changelog/#configuration-and-build-system-updates","title":"\u2699\ufe0f Configuration and Build System Updates","text":""},{"location":"usage/changelog/#project-configuration-enhancements","title":"Project Configuration Enhancements","text":"<ul> <li>Build system: Migrated from <code>hatchling</code> to <code>uv_build</code> for better integration with UV toolchain and improved build reliability</li> <li>MyPy configuration: Updated to include <code>no-redef</code> in <code>disable_error_code</code> list for better type checking compatibility</li> <li>Dependencies: Added <code>uv</code> to the development dependency group for comprehensive toolchain integration</li> <li>Python requirements: Updated syntax from <code>\"&gt;3.9,&lt;4.0\"</code> to <code>\"&gt;=3.9,&lt;4.0\"</code> for standard compliance</li> </ul>"},{"location":"usage/changelog/#documentation-configuration","title":"Documentation Configuration","text":"<ul> <li>MkDocs updates: </li> <li>Added new <code>generators</code> module to navigation structure for complete module coverage</li> <li>Fixed repository icon from <code>material/gitlab</code> to <code>material/github</code> for accurate branding</li> <li>Enhanced navigation structure to reflect all available modules</li> <li>Improved organization: Better categorization and presentation of module documentation</li> </ul>"},{"location":"usage/changelog/#enhanced-type-system","title":"Enhanced Type System","text":"<ul> <li>Collection types: Expanded <code>collection_types.py</code> with new type aliases:</li> <li>Added <code>datetime</code> collections: <code>datetime_list</code>, <code>datetime_tuple</code>, <code>datetime_set</code>, <code>datetime_list_tuple</code></li> <li>Added <code>int</code> collections: <code>int_set</code>, <code>int_list_tuple</code></li> <li>Enhanced <code>dict</code> collections: reorganized and added better documentation</li> <li>Improved organization with clear section comments for better maintainability</li> </ul>"},{"location":"usage/changelog/#testing-and-quality-assurance","title":"\ud83e\uddea Testing and Quality Assurance","text":""},{"location":"usage/changelog/#comprehensive-test-coverage","title":"Comprehensive Test Coverage","text":"<ul> <li>New test modules: Added extensive test coverage for new functionality:</li> <li><code>src/tests/test_generators.py</code> - Complete test suite for the generators module with edge cases</li> <li>Enhanced <code>src/tests/test_strings.py</code> - Tests for new <code>str_to_list()</code> function with various input types</li> <li>Expanded <code>src/tests/test_checkers.py</code> - Comprehensive tests for new validation functions including <code>OPERATORS</code> testing</li> <li>Test improvements: Updated existing tests to use <code>pytest.raises</code> instead of <code>pytest</code> imports for better compatibility</li> <li>Coverage maintenance: Maintained 100% test coverage across all modules while adding new functionality</li> </ul>"},{"location":"usage/changelog/#quality-improvements","title":"Quality Improvements","text":"<ul> <li>Validation robustness: Enhanced function robustness through comprehensive parameter validation using new assertion functions</li> <li>Error handling: Improved error capture and reporting in docstring checking with detailed feedback</li> <li>Type safety: Better type hints and validation across the codebase with overloads and proper type checking</li> <li>Code organization: Improved code structure with better separation of concerns and descriptive comments</li> </ul>"},{"location":"usage/changelog/#impact-and-benefits","title":"\ud83c\udfaf Impact and Benefits","text":"<p>This release significantly enhances the <code>toolbox-python</code> package by:</p> <ul> <li>Expanding core functionality with new modules and utilities that provide valuable data processing capabilities for on-demand computation</li> <li>Improving developer experience through better type hints, comprehensive validation, standardized tooling, and automated quality checks</li> <li>Enhancing code quality with comprehensive validation systems, consistent documentation standards, and robust error handling</li> <li>Modernizing CI/CD with migration to UV-based tooling for better reliability, performance, and maintainability</li> <li>Strengthening maintainability through comprehensive testing, automated docstring validation, and organized project scripts</li> <li>Improving type safety with enhanced type hints, validation functions, and comprehensive overloads for better IDE support</li> </ul>"},{"location":"usage/changelog/#pull-requests","title":"\ud83d\udcaa Pull Requests","text":"<ul> <li>Reorder classifiers and update Python requirement syntax in <code>pyproject.toml</code> by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/35</li> <li>Comprehensive Package Enhancement and Tooling Migration with new modules, improved validation, and modernized CI/CD workflows by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/36</li> </ul> <p>The changes maintain full backward compatibility while providing substantial improvements to functionality, developer experience, and project maintenance workflows. All existing APIs remain unchanged, ensuring seamless upgrades for existing users.</p> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.3.1...v1.4.0</p>"},{"location":"usage/changelog/#v132-update-package-config","title":"v1.3.2 - Update package config","text":"<p><code>v1.3.2</code> <code>2025-05-25</code> data-science-extensions/toolbox-python/releases/v1.3.2</p> Release Notes <p>This release updates the <code>pyproject.toml</code> file to enhance metadata clarity and correct the Python version requirement syntax. The most important changes include reorganizing and expanding the <code>classifiers</code> section and adjusting the <code>requires-python</code> field.</p> Updates <ul> <li>Reorder classifiers and update Python requirement syntax in <code>pyproject.toml</code> (by chrimaho) View</li> </ul>"},{"location":"usage/changelog/#whats-changed_1","title":"What's Changed","text":"<ul> <li>Reorder classifiers and update Python requirement syntax in <code>pyproject.toml</code> by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/35</li> </ul>"},{"location":"usage/changelog/#metadata-improvements","title":"Metadata improvements:","text":"<ul> <li>Reorganized and expanded the <code>classifiers</code> section to include additional topics such as <code>Testing :: Unit</code> and <code>Utilities</code>, improving the discoverability and categorization of the project.</li> </ul>"},{"location":"usage/changelog/#syntax-correction","title":"Syntax correction:","text":"<ul> <li>Updated the <code>requires-python</code> field from <code>\"&gt;3.9,&lt;4.0\"</code> to <code>\"&gt;=3.9,&lt;4.0\"</code> to align with standard version specification syntax.</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.3.1...v1.3.2</p>"},{"location":"usage/changelog/#v131-add-more-collection-types","title":"v1.3.1 - Add more collection types","text":"<p><code>v1.3.1</code> <code>2025-04-26</code> data-science-extensions/toolbox-python/releases/v1.3.1</p> Release Notes Updates <ul> <li> <p>Add build target location so that <code>hatchling</code> knows exactly where the package directory is (by chrimaho) View</p> </li> <li> <p>Add <code>uv-lock</code> and <code>uv-lock-sync</code> targets to Makefile (by chrimaho) View</p> </li> <li> <p>Add more collection types (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_2","title":"What's Changed","text":"<ul> <li>Add more Collection types by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/34</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.2.1...v1.3.1</p>"},{"location":"usage/changelog/#v121-add-new-class_property-decorator","title":"v1.2.1 - Add new <code>@class_property</code> decorator","text":"<p><code>v1.2.1</code> <code>2025-04-25</code> data-science-extensions/toolbox-python/releases/v1.2.1</p> Release Notes Updates <ul> <li> <p>Fix <code>Makefile</code> for when using <code>uv</code> commands to make it more robust</p> <ol> <li>Add <code>uv-shell</code> command</li> <li>Update all commands to use <code>--link-mode=copy</code> (by chrimaho) View</li> </ol> </li> <li> <p>Fix ignorances (by chrimaho) View</p> </li> <li> <p>Enhance <code>class_property</code> decorator with additional class-level properties, and add unit tests with 100% coverage (by chrimaho) View</p> </li> <li> <p>Add <code>@class_property</code> decorator and corresponding tests (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_3","title":"What's Changed","text":"<ul> <li>Add new <code>@class_property</code> decorator by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/33</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.2.0...v1.2.1</p>"},{"location":"usage/changelog/#v120-migrate-from-poetry-to-uv-and-add-new-dotdict-class","title":"v1.2.0 - Migrate from Poetry to UV and add new DotDict class","text":"<p><code>v1.2.0</code> <code>2025-04-06</code> data-science-extensions/toolbox-python/releases/v1.2.0</p> Release Notes Updates <ul> <li> <p>Fix bug (by chrimaho) View</p> </li> <li> <p>Fix bug in <code>src/toolbox_python/dictionaries.py::DotDict.to_dict()</code>     Co-authored-by: Copilot 175728472+Copilot@users.noreply.github.com (by chrimaho) View</p> </li> <li> <p>Remove redundant comments (by chrimaho) View</p> </li> <li> <p>Extend UnitTests for the <code>dictionaries</code> module (by chrimaho) View</p> </li> <li> <p>Fix bug. (by chrimaho) View</p> </li> <li> <p>Refactor <code>cd</code> workflow to use <code>uv</code> for building and publishing packages (by chrimaho) View</p> </li> <li> <p>Add the <code>bump_version</code> module to configs (by chrimaho) View</p> </li> <li> <p>Add new utility for <code>bump_version</code> (by chrimaho) View</p> </li> <li> <p>Add new <code>DotDict</code> class to the <code>dictionaries</code> module (by chrimaho) View</p> </li> <li> <p>Update CI/CD workflows to use <code>uv</code> processes (by chrimaho) View</p> </li> <li> <p>Update package config to use <code>uv</code> instead of <code>poetry</code> (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#primary-changes","title":"Primary Changes","text":"<ul> <li>Migrate build engine from Poetry to UV</li> <li>Add new <code>DotDict</code> class to handle accessing dictionary keys using <code>.attribute</code> syntax</li> <li>Add utility module <code>bump_version</code> for checking <code>pyproject.toml</code> and updating the version values across the respective files</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.1.0...v1.2.0</p>"},{"location":"usage/changelog/#v110-enhance-the-output-module","title":"v1.1.0 - Enhance the <code>output</code> module","text":"<p><code>v1.1.0</code> <code>2025-02-24</code> data-science-extensions/toolbox-python/releases/v1.1.0</p> Release Notes Updates <ul> <li> <p>bump optional package dependencies (by chrimaho) View</p> </li> <li> <p>Make Unit Tests a little more efficient (by chrimaho) View</p> </li> <li> <p>Fix linting (by chrimaho) View</p> </li> <li> <p>Restructure the <code>pyproject.toml</code> file to be compatible with the latest version of <code>poetry</code> (by chrimaho) View</p> </li> <li> <p>Change where the <code>__version__</code> property is stored (by chrimaho) View</p> </li> <li> <p>Enhance <code>list_columns()</code> function to accept different input types (by chrimaho) View</p> </li> <li> <p>Fix type definitions across all modules (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_4","title":"What's Changed","text":"<ul> <li>Update <code>list_columns()</code> function:<ul> <li>Allow the <code>obj</code> input to accept different input types</li> <li>Extend the Unit Tests</li> </ul> </li> <li>Update <code>pyproject.toml</code> file:<ul> <li>To match the structure of the latest <code>poetry</code> version</li> <li>To fix the location of where the <code>__version__</code> attribute is stored</li> </ul> </li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.0.4...v1.1.0</p>"},{"location":"usage/changelog/#v104","title":"v1.0.4","text":"<p><code>v1.0.4</code> <code>2024-12-13</code> data-science-extensions/toolbox-python/releases/v1.0.4</p> Release Notes Updates <ul> <li> <p>Fix type definitions across all modules (by chrimaho) View</p> </li> <li> <p>Fix another typo (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_5","title":"What's Changed","text":"<ul> <li>Fix type definitions across all modules.</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.0.3...v1.0.4</p>"},{"location":"usage/changelog/#v103","title":"v1.0.3","text":"<p><code>v1.0.3</code> <code>2024-12-13</code> data-science-extensions/toolbox-python/releases/v1.0.3</p> Release Notes Updates <ul> <li> <p>Fix another typo (by chrimaho) View</p> </li> <li> <p>Add images to docs (by chrimaho) View</p> </li> <li> <p>Streamline <code>deployment</code> steps in the <code>Makefile</code> (by chrimaho) View</p> </li> <li> <p>Add <code>dict_str_any</code> to <code>collection_types</code> module (by chrimaho) View</p> </li> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Fix Unit Test structure (by chrimaho) View</p> </li> <li> <p>Add <code>docstring-inheritance</code> to <code>docs</code> dependencies (by chrimaho) View</p> </li> <li> <p>Fix missing Python version check during <code>CI</code> workflow (by chrimaho) View</p> </li> <li> <p>Hide <code>.js</code> and <code>.css</code> from GitHub language stats (by chrimaho) View</p> </li> <li> <p>Hide <code>html</code> from GitHub language stats (by chrimaho) View</p> </li> <li> <p>Update package dependencies to make them more flexible (by chrimaho) View</p> </li> <li> <p>Fix bug (by chrimaho) View</p> </li> <li> <p>Fix permission issue (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_6","title":"What's Changed","text":"<ul> <li>Streamline a few functions in the Unit Tests module</li> <li>Add <code>dict_str_any</code> object to the <code>collection_types</code> module</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.0.2...v1.0.3</p>"},{"location":"usage/changelog/#v102","title":"v1.0.2","text":"<p><code>v1.0.2</code> <code>2024-11-10</code> data-science-extensions/toolbox-python/releases/v1.0.2</p> Release Notes Updates <ul> <li> <p>Fix permission issue (by chrimaho) View</p> </li> <li> <p>Fix failing <code>CD</code> workflow (by chrimaho) View</p> </li> <li> <p>Fix failing <code>CI</code> workflow (by chrimaho) View</p> </li> <li> <p>Add <code>git</code> credentials during <code>CD</code> workflow (by chrimaho) View</p> </li> <li> <p>Re-enable <code>PyPI</code> deployment during <code>CD</code> workflow (by chrimaho) View</p> </li> <li> <p>Enhance <code>CD</code> workflow to better handle Code Cov reports (by chrimaho) View</p> </li> <li> <p>Fix structure of <code>code</code> docs page (by chrimaho) View</p> </li> <li> <p>Fix <code>mike</code> config to remove <code>deploy-prefix</code> setting (by chrimaho) View</p> </li> <li> <p>Remove unnecessary <code>code-cov</code> flags in the <code>pytest</code> config (by chrimaho) View</p> </li> <li> <p>Streamline <code>Makefile</code> to remove unnecessary recipes, and add one to copy code-cov reports (by chrimaho) View</p> </li> <li> <p>Update CodeCov reports (by chrimaho) View</p> </li> <li> <p>Remove unnecessary variables in the <code>CD</code> workflow (by chrimaho) View</p> </li> <li> <p>Remove unnecessary <code>deploy-docs</code> job from <code>CD</code> workflow (by chrimaho) View</p> </li> <li> <p>Add <code>git config</code> using both <code>--global</code> and <code>--local</code> flags (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_7","title":"What's Changed","text":"<ul> <li>Refactor how the coverage reports are handled in the docs.</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.0.1...v1.0.2</p>"},{"location":"usage/changelog/#v101","title":"v1.0.1","text":"<p><code>v1.0.1</code> <code>2024-11-10</code> data-science-extensions/toolbox-python/releases/v1.0.1</p> Release Notes Updates <ul> <li> <p>Add <code>git config</code> using both <code>--global</code> and <code>--local</code> flags (by chrimaho) View</p> </li> <li> <p>Fix typos (by chrimaho) View</p> </li> <li> <p>Fix typos (by chrimaho) View</p> </li> <li> <p>Try new authentication username (by chrimaho) View</p> </li> <li> <p>Update <code>remote</code> url (by chrimaho) View</p> </li> <li> <p>Check <code>git config</code> from mid-workflow (by chrimaho) View</p> </li> <li> <p>Add checks (by chrimaho) View</p> </li> <li> <p>Do testing on env variables parsed to <code>make</code> commands (by chrimaho) View</p> </li> <li> <p>Add permissions again to <code>CD</code> workflow file (by chrimaho) View</p> </li> <li> <p>Fix authentication issue between repos (by chrimaho) View</p> </li> <li> <p>Fix package URLs (by chrimaho) View</p> </li> <li> <p>Remove <code>deploy-docs</code> from the <code>CD</code> workflow (by chrimaho) View</p> </li> <li> <p>Enhance <code>Makefile</code> to make recipes more robust and also add <code>--remote=docs</code> flag to all <code>mike</code> commands (by chrimaho) View</p> </li> <li> <p>Fix spacing on README shields (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_8","title":"What's Changed","text":"<ul> <li>Fix some minor typos on the docs.</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v1.0.0...v1.0.1</p>"},{"location":"usage/changelog/#v100","title":"v1.0.0","text":"<p><code>v1.0.0</code> <code>2024-11-05</code> data-science-extensions/toolbox-python/releases/v1.0.0</p> Release Notes Updates <ul> <li>Re-enable PyPI deployment step (by chrimaho) View</li> </ul>"},{"location":"usage/changelog/#whats-changed_9","title":"What's Changed","text":"<ul> <li>First major release.</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.1.1...v1.0.0</p>"},{"location":"usage/changelog/#v0103","title":"v0.10.3","text":"<p><code>v0.10.3</code> <code>2024-11-05</code> data-science-extensions/toolbox-python/releases/v0.10.3</p> Release Notes Updates <ul> <li> <p>Re-enable PyPI deployment step (by chrimaho) View</p> </li> <li> <p>Update development Status (by chrimaho) View</p> </li> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Fix up badges on README file (by chrimaho) View</p> </li> <li> <p>Fix links for logos on home page (by chrimaho) View</p> </li> <li> <p>Add <code>deploy_prefix</code> to the <code>mike deploy</code> process (by chrimaho) View</p> </li> <li> <p>Add step to <code>cd</code> workflow to properly handle <code>CNAME</code> file (by chrimaho) View</p> </li> <li> <p>Fix alignment in README (by chrimaho) View</p> </li> <li> <p>Fix another typo (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_10","title":"What's Changed","text":"<ul> <li>Fix bugs in docs, and correct directory structure</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.10.2...v0.10.3</p>"},{"location":"usage/changelog/#v0102","title":"v0.10.2","text":"<p><code>v0.10.2</code> <code>2024-11-03</code> data-science-extensions/toolbox-python/releases/v0.10.2</p> Release Notes Updates <ul> <li> <p>Fix another typo (by chrimaho) View</p> </li> <li> <p>Centre-align header in README (by chrimaho) View</p> </li> <li> <p>Fix another typo (by chrimaho) View</p> </li> <li> <p>Fix missing permissions (by chrimaho) View</p> </li> <li> <p>Fix typos (by chrimaho) View</p> </li> <li> <p>Fix missing <code>pypi</code> token from the <code>deploy-package</code> job in the <code>cd</code> workflow (by chrimaho) View</p> </li> <li> <p>Fix artifacts used between jobs in the <code>cd</code> workflow (by chrimaho) View</p> </li> <li> <p>Fix triggers for <code>cd</code> workflow (by chrimaho) View</p> </li> <li> <p>Restructure how the <code>cd</code> workflow works, splitting out the <code>build</code> and <code>deploy</code> steps for both the <code>pypi</code> and <code>docs</code> jobs (by chrimaho) View</p> </li> <li> <p>Remove <code>deploy_prefix</code> from <code>mike</code> builds (by chrimaho) View</p> </li> <li> <p>Rearrange the directory structure for the docs (by chrimaho) View</p> </li> <li> <p>Fix <code>docs</code> commands for <code>build</code>/<code>serve</code> processes (by chrimaho) View</p> </li> <li> <p>Add <code>black</code> to <code>docs</code> dependencies (by chrimaho) View</p> </li> <li> <p>Fix <code>deploy_prefix</code> for <code>mike</code> docs deployments (by chrimaho) View</p> </li> <li> <p>add <code>make serve-docs-mike</code> command (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_11","title":"What's Changed","text":"<ul> <li>Fix directory structure for docs</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.10.1...v0.10.2</p>"},{"location":"usage/changelog/#v0101","title":"v0.10.1","text":"<p><code>v0.10.1</code> <code>2024-11-03</code> data-science-extensions/toolbox-python/releases/v0.10.1</p> Release Notes Updates <ul> <li> <p>Fix another typo (by chrimaho) View</p> </li> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Add <code>docs</code> deployment script to GH Actions (by chrimaho) View</p> </li> <li> <p>Fix <code>actions/setup-python</code> version in GitHub Actions (by chrimaho) View</p> </li> <li> <p>Update <code>mike</code> docs deployment scripts (by chrimaho) View</p> </li> <li> <p>Update versions in <code>pre-commit</code>  config file (by chrimaho) View</p> </li> <li> <p>Fix typos (by chrimaho) View</p> </li> <li> <p>Add <code>ipykernel</code> to list of <code>dev</code> dependencies (by chrimaho) View</p> </li> <li> <p>Fix install scripts (by chrimaho) View</p> </li> <li> <p>Enhance the custom <code>css</code> for both <code>admonitions</code> and <code>code-chunks</code> (by chrimaho) View</p> </li> <li> <p>Fix examples for the docstrings in all functions in all modules. (by chrimaho) View</p> </li> <li> <p>Update ci.yml (by chrimaho) View</p> </li> <li> <p>Update Makefile (by chrimaho) View</p> </li> <li> <p>Add <code>codecov</code> step to <code>CD</code> pipeline (by chrimaho) View</p> </li> <li> <p>Add <code>README</code> to <code>overview</code> docs page (by chrimaho) View</p> </li> <li> <p>Add new check for <code>mkdocs</code> build (by chrimaho) View</p> </li> <li> <p>Update the <code>README</code> (by chrimaho) View</p> </li> <li> <p>Fix typos (by chrimaho) View</p> </li> <li> <p>Add docs for the <code>defaults</code> module (by chrimaho) View</p> </li> <li> <p>Add docs for the <code>retry</code> module (by chrimaho) View</p> </li> <li> <p>Fix typos in the <code>Examples</code> sections for each of the docstrings (by chrimaho) View</p> </li> <li> <p>Add docs for the <code>output</code> module (by chrimaho) View</p> </li> <li> <p>Fix typos (by chrimaho) View</p> </li> <li> <p>Update <code>code-cov</code> report (by chrimaho) View</p> </li> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Fix missing exports from the <code>checkers</code> module (by chrimaho) View</p> </li> <li> <p>Update unit tests for the <code>checkers</code> module (by chrimaho) View</p> </li> <li> <p>Fix failing unit tests from the <code>lists</code> module (by chrimaho) View</p> </li> <li> <p>Expand predefined types from the <code>collection_types</code> module (by chrimaho) View</p> </li> <li> <p>Finish adding docs to the <code>checkers</code> module (by chrimaho) View</p> </li> <li> <p>Add docs for the <code>dictionaries</code> module (by chrimaho) View</p> </li> <li> <p>Fix typos (by chrimaho) View</p> </li> <li> <p>Add docs for the <code>strings</code> module (by chrimaho) View</p> </li> <li> <p>Add the docs for the <code>lists</code> module (by chrimaho) View</p> </li> <li> <p>Add the docs for the <code>classes</code> module (by chrimaho) View</p> </li> <li> <p>Fix version values in all dependencies (by chrimaho) View</p> </li> <li> <p>Update <code>code-cov</code> report (by chrimaho) View</p> </li> <li> <p>Fix typos (by chrimaho) View</p> </li> <li> <p>Add docs for <code>bools</code> module (by chrimaho) View</p> </li> <li> <p>Set up configuration for the <code>mkdocs</code> documentation (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_12","title":"What's Changed","text":"<ul> <li>Add Documentation by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/28</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.9.1...v0.10.1</p>"},{"location":"usage/changelog/#v091","title":"v0.9.1","text":"<p><code>v0.9.1</code> <code>2024-10-13</code> data-science-extensions/toolbox-python/releases/v0.9.1</p> Release Notes Updates <ul> <li> <p>Fix typos (by chrimaho) View</p> </li> <li> <p>Add <code>retry</code> module and all unit tests (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_13","title":"What's Changed","text":"<ul> <li>Add <code>retry</code> module and all unit tests by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/26</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.8.1...v0.9.1</p>"},{"location":"usage/changelog/#v081","title":"v0.8.1","text":"<p><code>v0.8.1</code> <code>2024-10-13</code> data-science-extensions/toolbox-python/releases/v0.8.1</p> Release Notes Updates <ul> <li>Add <code>output</code> module and all unit tests (by chrimaho) View</li> </ul>"},{"location":"usage/changelog/#whats-changed_14","title":"What's Changed","text":"<ul> <li>Add <code>output</code> module and all unit tests by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/25</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.7.1...v0.8.1</p>"},{"location":"usage/changelog/#v071","title":"v0.7.1","text":"<p><code>v0.7.1</code> <code>2024-10-13</code> data-science-extensions/toolbox-python/releases/v0.7.1</p> Release Notes Updates <ul> <li>Add <code>*_contains()</code> functions to <code>checkers</code> module (by ) View</li> </ul>"},{"location":"usage/changelog/#whats-changed_15","title":"What's Changed","text":"<ul> <li>Add <code>*_contains()</code> functions to <code>checkers</code> module by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/23</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.6.1...v0.7.1</p>"},{"location":"usage/changelog/#v061","title":"v0.6.1","text":"<p><code>v0.6.1</code> <code>2024-10-12</code> data-science-extensions/toolbox-python/releases/v0.6.1</p> Release Notes Updates <ul> <li> <p>Add <code>lists</code> module and all unit tests (by ) View</p> </li> <li> <p>Add <code>more-itertools</code> to main dependencies (by ) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_16","title":"What's Changed","text":"<ul> <li>Add <code>lists</code> module by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/22</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.5.1...v0.6.1</p>"},{"location":"usage/changelog/#v051","title":"v0.5.1","text":"<p><code>v0.5.1</code> <code>2024-10-12</code> data-science-extensions/toolbox-python/releases/v0.5.1</p> Release Notes Updates <ul> <li> <p>Fix <code>ci</code> workflow triggers (by ) View</p> </li> <li> <p>Add <code>strings</code> module and all unit tests (by ) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_17","title":"What's Changed","text":"<ul> <li>Add <code>strings</code> module and all unit tests by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/21</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.4.1...v0.5.1</p>"},{"location":"usage/changelog/#v041","title":"v0.4.1","text":"<p><code>v0.4.1</code> <code>2024-10-12</code> data-science-extensions/toolbox-python/releases/v0.4.1</p> Release Notes Updates <ul> <li>Add <code>classes</code> module and all unit tests (by ) View</li> </ul>"},{"location":"usage/changelog/#whats-changed_18","title":"What's Changed","text":"<ul> <li>Add <code>classes</code> module by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/16</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.3.1...v0.4.1</p>"},{"location":"usage/changelog/#v031","title":"v0.3.1","text":"<p><code>v0.3.1</code> <code>2024-10-12</code> data-science-extensions/toolbox-python/releases/v0.3.1</p> Release Notes Updates <ul> <li> <p>Add <code>defaults</code> module and all unit tests (by ) View</p> </li> <li> <p>Fix typos (by ) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_19","title":"What's Changed","text":"<ul> <li>Add <code>defaults</code> module by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/15</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.2.1...v0.3.1</p>"},{"location":"usage/changelog/#v021","title":"v0.2.1","text":"<p><code>v0.2.1</code> <code>2024-10-12</code> data-science-extensions/toolbox-python/releases/v0.2.1</p> Release Notes Updates <ul> <li> <p>Fix type bugs for Python 3.9 (by ) View</p> </li> <li> <p>Complete unit tests for the <code>checkers</code> module (by ) View</p> </li> <li> <p>Fix <code>mypy</code> errors (by ) View</p> </li> <li> <p>Add the <code>dictionaries</code> module and unit tests (by ) View</p> </li> <li> <p>Streamline the unit tests for the <code>bools</code> module (by ) View</p> </li> <li> <p>Expand <code>collection_types</code> module (by ) View</p> </li> <li> <p>Add generic functions for unit tests (by ) View</p> </li> <li> <p>Fix install commands (by ) View</p> </li> <li> <p>Add <code>parameterized</code> to the <code>test</code> dependencies (by ) View</p> </li> <li> <p>Reformat the descriptions in the <code>bools</code> module (by ) View</p> </li> <li> <p>Add the <code>collection_types</code> and <code>checkers</code> modules (by ) View</p> </li> <li> <p>Fix version (by ) View</p> </li> <li> <p>Add URLs back in to config (by ) View</p> </li> <li> <p>Fix version (by ) View</p> </li> <li> <p>Add URLs back in to config (by ) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_20","title":"What's Changed","text":"<ul> <li>Add URLs back in to config by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/9</li> <li>Fix Merge config by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/10</li> <li>Add <code>dictionaries</code> module and all Unit Tests by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/11</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/compare/v0.1.1...v0.2.1</p>"},{"location":"usage/changelog/#v011","title":"v0.1.1","text":"<p><code>v0.1.1</code> <code>2024-10-12</code> data-science-extensions/toolbox-python/releases/v0.1.1</p> Release Notes Updates <ul> <li> <p>Fix (by ) View</p> </li> <li> <p>Clean up workflows (by ) View</p> </li> <li> <p>Check whether <code>git</code> can checkout the <code>main</code> branch during workflow (by ) View</p> </li> <li> <p>Check <code>git</code> switch to new branch (by ) View</p> </li> <li> <p>Fix missing <code>git</code> repo (by ) View</p> </li> <li> <p>Check Git details (by ) View</p> </li> <li> <p>Add process to push updated version back to Git <code>main</code> branch (by ) View</p> </li> <li> <p>Hide URLs from <code>pypoetry</code> config file (by ) View</p> </li> <li> <p>Fix permissions in <code>cd</code> workflow (by ) View</p> </li> <li> <p>Add step to upload assets to the release, and also turn off <code>--dry-run</code> for pypi upload (by ) View</p> </li> <li> <p>Add <code>cd</code> workflow (by ) View</p> </li> <li> <p>Add more debugging scripts (by ) View</p> </li> <li> <p>Fix typos (by ) View</p> </li> <li> <p>Enhance the <code>ci</code> workflow to do some debugging (by ) View</p> </li> <li> <p>Extend <code>ci</code> workflow to include extensive checking when merge to <code>main</code> (by ) View</p> </li> <li> <p>Enhance poetry install commands (by ) View</p> </li> <li> <p>Add <code>ci</code> file to run checks when push to any branch except <code>main</code> (by ) View</p> </li> <li> <p>Add <code>Makefile</code> commands (by ) View</p> </li> <li> <p>Hide <code>pipenv</code> config files (by ) View</p> </li> <li> <p>Clean comments (by ) View</p> </li> <li> <p>Fix <code>pre-commit</code> config (by ) View</p> </li> <li> <p>Enhance install scripts (by ) View</p> </li> <li> <p>Add all relevant modules (by ) View</p> </li> <li> <p>Update main config file (by ) View</p> </li> <li> <p>Add <code>pyupgrade</code> to <code>pre-commit</code> config (by ) View</p> </li> <li> <p>Add <code>.pre-commit</code> config (by ) View</p> </li> <li> <p>Add installation config and scripts (by ) View</p> </li> <li> <p>Add info to <code>bools</code> module (by chrimaho) View</p> </li> <li> <p>Add <code>bools</code> module (by chrimaho) View</p> </li> <li> <p>Initial commit (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_21","title":"What's Changed","text":"<ul> <li>Updates by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/1</li> <li>Dev by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/2</li> <li>Dev by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/3</li> <li>Dev by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/4</li> <li>Dev by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/5</li> <li>Dev by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/6</li> <li>Dev by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/7</li> <li>Dev by @chrimaho in https://github.com/data-science-extensions/toolbox-python/pull/8</li> </ul>"},{"location":"usage/changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@chrimaho made their first contribution in https://github.com/data-science-extensions/toolbox-python/pull/1</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/toolbox-python/commits/v0.1.1</p>"},{"location":"usage/contributing/","title":"Contribution Guidelines","text":"<p>All contributions are welcome! Please follow these guidelines to ensure a smooth contribution process.</p>"},{"location":"usage/contributing/#overview","title":"Overview","text":"<p>Here are some guidelines to help you get started:</p> <ol> <li>Raise an Issue: Before starting work on a new feature or bug fix, please raise an issue to discuss it. All enhancements and changes are discussed in the issues section. This helps us avoid duplicate work and ensures that your contribution aligns with the project's goals.</li> <li>Check the issues and milestones: Look at the issues and milestones to see if your contribution fits into the current roadmap.</li> <li>Fork the Repository: Create a fork of the repository to work on your changes. This allows you to make changes without affecting the main codebase.</li> <li>Create a new branch: When working on a new feature or bug fix, create a new branch from the <code>main</code> branch. Use a descriptive name for your branch that reflects the changes you are making.</li> <li>Clone the repository: Clone your forked repository to your local machine to start working on it.</li> <li>Creating your environment: Set up your development environment according to the project's requirements. This may include installing dependencies, setting up virtual environments, and configuring tools like uv, pre-commit, pytest, and mypy.</li> <li>Make your changes: Implement your changes in the new branch. Ensure that your code adheres to the project's coding standards and style guidelines.</li> <li>Commit your changes: Commit your changes with a clear and descriptive commit message.</li> <li>Write tests: If you are adding new features or fixing bugs, please write tests to ensure that your changes work as expected.</li> <li>Submit a Pull Request: Once you have made your changes and committed them, submit a pull request to the main repository. Provide a clear description of the changes you made and reference any related issues.</li> </ol>"},{"location":"usage/contributing/#raise-an-issue","title":"Raise an Issue","text":"<p>If you find a bug or have a feature request, please raise an issue. This helps us track and prioritize contributions effectively.</p> <p>Raise an Issue</p> <p>When raising an issue, please follow these guidelines to ensure clarity and effectiveness:</p> <ol> <li>Title: Provide a clear and concise title that summarizes the issue or feature request.</li> <li>Description: Include a detailed description of the issue or feature request. Explain what the problem is, how it can be reproduced, and any relevant context.</li> <li>Steps to Reproduce: If applicable, provide a step-by-step guide on how to reproduce the issue. This helps us understand the problem better.</li> <li>Expected vs Actual Behavior: Describe what you expected to happen and what actually happened. This helps clarify the issue.</li> <li>Screenshots or Logs: If possible, include screenshots or logs that illustrate the issue. This can be very helpful for debugging.</li> <li>Context: Provide any additional context that might be relevant, such as the environment in which the issue occurred (e.g., operating system, Python version, etc.).</li> </ol>"},{"location":"usage/contributing/#issues-and-milestones","title":"Issues and Milestones","text":"<p>We are using issues to track bugs, feature requests, and enhancements, and milestones to organize these issues into manageable chunks.</p> <p>If you want to contribute to the project, please check the current issues and milestones before starting work to ensure that your contribution aligns with the project's goals and priorities. This will help avoid duplication of effort and ensure that your contributions align with the project's roadmap. If you want to add something that is not already listed in the milestones, please raise an issue to discuss it first.</p> <p>You can view the current issues and milestones on the project's GitHub page.</p> <p>View Issues</p> <p>View Milestones</p>"},{"location":"usage/contributing/#create-a-fork","title":"Create a Fork","text":"<p>To contribute to this project, you need to create a fork of the repository. This allows you to make changes without affecting the main codebase.</p> <p>Create a Fork</p>"},{"location":"usage/contributing/#create-a-new-branch","title":"Create a New Branch","text":"<p>When working on a new feature or bug fix, create a new branch from the <code>main</code> branch. Use a descriptive name for your branch that reflects the changes you are making.</p> <p>Create a New Branch</p>"},{"location":"usage/contributing/#clone-the-repository","title":"Clone the Repository","text":"<p>To start working on your forked repository, you need to clone it to your local machine. This allows you to make changes and test them locally before submitting a pull request.</p>"},{"location":"usage/contributing/#creating-your-environment","title":"Creating your Environment","text":"<p>When you are ready to start working on your changes, set up your development environment according to the project's requirements. In this project, we use uv to manage the Python environments, pre-commit for code quality checks, and pytest for testing.</p> <p>Follow these steps to set up your environment:</p> <ol> <li>Install uv: Follow the instructions in the uv installation guide to install uv.     <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre></li> <li>Sync the environment: Use <code>uv</code> to set up the environment with the required dependencies.     <pre><code>uv sync --all-groups --link-mode=copy\n</code></pre></li> <li>Install pre-commit: Install pre-commit to manage code quality checks.     <pre><code>uv run --link-mode=copy pre-commit install\n</code></pre></li> <li>Update pre-commit hooks: Ensure that the pre-commit hooks are up to date.     <pre><code>uv run --link-mode=copy pre-commit autoupdate\n</code></pre></li> </ol>"},{"location":"usage/contributing/#make-your-changes","title":"Make Your Changes","text":"<p>Make your changes in the new branch you created. Ensure that your code adheres to the project's coding standards and style guidelines. If you are adding new features or fixing bugs, please write tests to ensure that your changes work as expected.</p> <p>Ensure you follow the project's coding standards and style guidelines. This includes:</p> <ol> <li>Code Style: Follow the PEP 8 style guide for Python code.</li> <li>Docstrings: Use clear and concise docstrings for all functions, classes, and modules. Ensure that they follow the Google styleguide.</li> <li>Testing: Write unit tests for your code using unittest or pytest. Ensure that your tests cover all new functionality and edge cases.</li> <li>Code Coverage: Maintain high code coverage for your tests. Use Codecov to check your coverage reports.</li> <li>Type Checking: Use mypy for static type checking. Ensure that your code passes all type checks.</li> </ol> <p>Because you have set up <code>pre-commit</code>, these checks will be run automatically when you commit your changes. If any checks fail, you will need to fix them before you can successfully commit your changes. Further checks will also be run when you submit a pull request, so it's a good idea to ensure your code passes all checks before proceeding.</p>"},{"location":"usage/contributing/#commit-your-changes","title":"Commit Your Changes","text":"<p>Once you have made your changes, commit them with a clear and descriptive commit message. This helps reviewers understand the purpose of your changes. A good commit message should:</p> <ul> <li>Start with a short summary of the changes (50 characters or less).</li> <li>Follow the summary with a blank line.</li> <li>Provide a detailed description of the changes, including why they were made and any relevant context.</li> <li>Use the imperative mood (e.g., \"Add feature\" instead of \"Added feature\").</li> <li>Reference any related issues or pull requests.</li> <li>Use bullet points or paragraphs to organize the description for readability.</li> <li>Avoid using vague terms like \"fixes\" or \"changes\" without context.</li> <li>Be concise but informative, providing enough detail for someone unfamiliar with the code to understand the changes.</li> <li>Avoid including unnecessary information or personal opinions.</li> <li>Use proper grammar and punctuation to enhance clarity.</li> <li>If applicable, include any relevant links to documentation or resources that provide additional context for the changes.</li> <li>If the commit is related to a specific issue, include the issue number in the commit message (e.g., \"Fixes #123\").</li> <li>If the commit is part of a larger feature or task, consider using a prefix like \"feat:\", \"fix:\", or \"chore:\" to categorize the commit (e.g., \"feat: add new feature for user authentication\").</li> <li>If the commit is a work in progress, consider using a prefix like \"WIP:\" to indicate that it is not yet complete (e.g., \"WIP: start implementing new feature for user authentication\").</li> <li>If the commit is a refactor or cleanup, consider using a prefix like \"refactor:\" to indicate that it does not introduce new functionality (e.g., \"refactor: improve code readability and maintainability\").</li> <li>If the commit is a documentation update, consider using a prefix like \"docs:\" to indicate that it only affects documentation (e.g., \"docs: update README with installation instructions\").</li> <li>If the commit is a test update, consider using a prefix like \"test:\" to indicate that it only affects tests (e.g., \"test: add unit tests for new feature\").</li> </ul> <p>Ensure that any pre-commit checks pass before committing your changes. This includes code style checks, linting, and tests. If any checks fail, you will need to fix them before you can successfully commit your changes.</p>"},{"location":"usage/contributing/#submit-a-pull-request","title":"Submit a Pull Request","text":"<p>Once you have made your changes and committed them, submit a pull request to the main repository. Provide a clear description of the changes you made and reference any related issues.</p> <p>When submitting a pull request, please follow these guidelines:</p> <ol> <li>Title: Use a clear and descriptive title that summarizes the changes you made.</li> <li>Description: Provide a detailed description of the changes you made, including:</li> <li>What the changes do.</li> <li>Why the changes were made.</li> <li>Any relevant context or background information.</li> <li>How to test the changes.</li> <li>Reference Issues: If your changes address a specific issue, reference it in the pull request description (e.g., \"Fixes #123\" or \"Closes #123).</li> <li>Link to Related Pull Requests: If your changes are related to other pull requests, link to them in the description.</li> <li>Reviewers: Optionally, you can request specific reviewers to review your pull request.</li> <li>Milestone: Optionally, you can assign your pull request to a specific milestone if it is related to a larger feature or task.</li> <li>Check for Merge Conflicts: Ensure that your branch is up to date with the main branch and that there are no merge conflicts. If there are conflicts, resolve them before submitting the pull request.</li> <li>Be Responsive: Be prepared to respond to feedback from reviewers. They may request changes or ask for clarification on certain aspects of your pull request. Address their comments promptly and respectfully.</li> <li>Be Patient: Reviewers may take some time to review your pull request, especially if they are busy with other tasks. Be patient and give them time to provide feedback.</li> <li>Follow Up: After your pull request is merged, consider following up with any additional changes or improvements based on feedback from the review process. This helps maintain a high-quality codebase and shows that you are committed to improving the project.</li> </ol> <p>Submit a Pull Request</p>"},{"location":"usage/overview/","title":"Overview","text":"<code>toolbox-python</code>"},{"location":"usage/overview/#introduction","title":"Introduction","text":"<p>The purpose of this package is to provide some helper files/functions/classes for generic Python processes.</p>"},{"location":"usage/overview/#key-urls","title":"Key URLs","text":"<p>For reference, these URL's are used:</p> Type Source URL Git Repo GitHub https://github.com/data-science-extensions/toolbox-python Python Package PyPI https://pypi.org/project/toolbox-python Package Docs Pages https://data-science-extensions.com/python-toolbox/"},{"location":"usage/overview/#installation","title":"Installation","text":"<p>You can install and use this package multiple ways by using <code>pip</code>, <code>pipenv</code>, or <code>poetry</code>.</p>"},{"location":"usage/overview/#using-pip","title":"Using <code>pip</code>:","text":"<ol> <li> <p>In your terminal, run:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install toolbox-python\n</code></pre> </li> <li> <p>Or, in your <code>requirements.txt</code> file, add:</p> <pre><code>toolbox-python\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install --requirement=requirements.txt\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-pipenv","title":"Using <code>pipenv</code>:","text":"<ol> <li> <p>Install using environment variables:</p> <p>In your <code>Pipfile</code> file, add:</p> <pre><code>[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = false\nname = \"pypi\"\n\n[packages]\ntoolbox-python = \"*\"\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pip install pipenv\npython3 -m pipenv install --verbose --skip-lock --categories=root index=pypi toolbox-python\n</code></pre> </li> <li> <p>Or, in your <code>requirements.txt</code> file, add:</p> <pre><code>toolbox-python\n</code></pre> <p>Then run:</p> <pre><code>python3 -m run pipenv install --verbose --skip-lock --requirements=requirements.txt\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>python3 -m pipenv install --verbose --skip-lock toolbox-python\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-poetry","title":"Using <code>poetry</code>:","text":"<ol> <li> <p>In your <code>pyproject.toml</code> file, add:</p> <pre><code>[tool.poetry.dependencies]\ntoolbox-python = \"*\"\n</code></pre> <p>Then run:</p> <pre><code>poetry install\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>poetry add toolbox-python\npoetry install\npoetry sync\n</code></pre> </li> </ol>"},{"location":"usage/overview/#contribution","title":"Contribution","text":"<p>Contribution is always welcome.</p> <ol> <li> <p>First, either fork or branch the main repo.</p> </li> <li> <p>Clone your forked/branched repo.</p> </li> <li> <p>Build your environment:</p> <ol> <li> <p>With <code>pipenv</code> on Windows:</p> <pre><code>if (-not (Test-Path .venv)) {mkdir .venv}\npython -m pipenv install --requirements requirements.txt --requirements requirements-dev.txt --skip-lock\npython -m poetry run pre-commit install\npython -m poetry shell\n</code></pre> </li> <li> <p>With <code>pipenv</code> on Linux:</p> <pre><code>mkdir .venv\npython3 -m pipenv install --requirements requirements.txt --requirements requirements-dev.txt --skip-lock\npython3 -m poetry run pre-commit install\npython3 -m poetry shell\n</code></pre> </li> <li> <p>With <code>poetry</code> on Windows:</p> <pre><code>python -m pip install --upgrade pip\npython -m pip install poetry\npython -m poetry init\npython -m poetry add $(cat requirements/root.txt)\npython -m poetry add --group=dev $(cat requirements/dev.txt)\npython -m poetry add --group=test $(cat requirements/test.txt)\npython -m poetry add --group=docs $(cat requirements/docs.txt)\npython -m poetry install\npython -m poetry run pre-commit install\npython -m poetry shell\n</code></pre> </li> <li> <p>With <code>poetry</code> on Linux:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install poetry\npython3 -m poetry init\npython3 -m poetry add $(cat requirements/root.txt)\npython3 -m poetry add --group=dev $(cat requirements/dev.txt)\npython3 -m poetry add --group=test $(cat requirements/test.txt)\npython3 -m poetry add --group=docs $(cat requirements/docs.txt)\npython3 -m poetry install\npython3 -m poetry run pre-commit install\npython3 -m poetry shell\n</code></pre> </li> </ol> </li> <li> <p>Start contributing.</p> </li> <li> <p>When you're happy with the changes, raise a Pull Request to merge with the main branch again.</p> </li> </ol>"},{"location":"usage/overview/#build-and-test","title":"Build and Test","text":"<p>To ensure that the package is working as expected, please ensure that:</p> <ol> <li>You write your code as per PEP8 requirements.</li> <li>You write a UnitTest for each function/feature you include.</li> <li>The CodeCoverage is 100%.</li> <li>All UnitTests are passing.</li> <li>MyPy is passing 100%.</li> </ol>"},{"location":"usage/overview/#testing","title":"Testing","text":"<ul> <li> <p>Run them all together</p> <pre><code>poetry run make check\n</code></pre> </li> <li> <p>Or run them individually:</p> <ul> <li> <p>Black <pre><code>poetry run make check-black\n</code></pre></p> </li> <li> <p>PyTests:     <pre><code>poetry run make ckeck-pytest\n</code></pre></p> </li> <li> <p>MyPy:     <pre><code>poetry run make check-mypy\n</code></pre></p> </li> </ul> </li> </ul>"}]}